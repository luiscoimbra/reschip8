/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bs-platform/lib/js/belt_Array.js":
/*!*******************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/belt_Array.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar Curry = __webpack_require__(/*! ./curry.js */ \"./node_modules/bs-platform/lib/js/curry.js\");\nvar Js_math = __webpack_require__(/*! ./js_math.js */ \"./node_modules/bs-platform/lib/js/js_math.js\");\nvar Caml_option = __webpack_require__(/*! ./caml_option.js */ \"./node_modules/bs-platform/lib/js/caml_option.js\");\nvar Caml_primitive = __webpack_require__(/*! ./caml_primitive.js */ \"./node_modules/bs-platform/lib/js/caml_primitive.js\");\n\nfunction get(arr, i) {\n  if (i >= 0 && i < arr.length) {\n    return Caml_option.some(arr[i]);\n  }\n  \n}\n\nfunction getExn(arr, i) {\n  if (!(i >= 0 && i < arr.length)) {\n    throw {\n          RE_EXN_ID: \"Assert_failure\",\n          _1: [\n            \"belt_Array.ml\",\n            27,\n            4\n          ],\n          Error: new Error()\n        };\n  }\n  return arr[i];\n}\n\nfunction set(arr, i, v) {\n  if (i >= 0 && i < arr.length) {\n    arr[i] = v;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction setExn(arr, i, v) {\n  if (!(i >= 0 && i < arr.length)) {\n    throw {\n          RE_EXN_ID: \"Assert_failure\",\n          _1: [\n            \"belt_Array.ml\",\n            33,\n            2\n          ],\n          Error: new Error()\n        };\n  }\n  arr[i] = v;\n  \n}\n\nfunction swapUnsafe(xs, i, j) {\n  var tmp = xs[i];\n  xs[i] = xs[j];\n  xs[j] = tmp;\n  \n}\n\nfunction shuffleInPlace(xs) {\n  var len = xs.length;\n  for(var i = 0; i < len; ++i){\n    swapUnsafe(xs, i, Js_math.random_int(i, len));\n  }\n  \n}\n\nfunction shuffle(xs) {\n  var result = xs.slice(0);\n  shuffleInPlace(result);\n  return result;\n}\n\nfunction reverseInPlace(xs) {\n  var len = xs.length;\n  var ofs = 0;\n  for(var i = 0 ,i_finish = len / 2 | 0; i < i_finish; ++i){\n    swapUnsafe(xs, ofs + i | 0, ((ofs + len | 0) - i | 0) - 1 | 0);\n  }\n  \n}\n\nfunction reverse(xs) {\n  var len = xs.length;\n  var result = new Array(len);\n  for(var i = 0; i < len; ++i){\n    result[i] = xs[(len - 1 | 0) - i | 0];\n  }\n  return result;\n}\n\nfunction make(l, f) {\n  if (l <= 0) {\n    return [];\n  }\n  var res = new Array(l);\n  for(var i = 0; i < l; ++i){\n    res[i] = f;\n  }\n  return res;\n}\n\nfunction makeByU(l, f) {\n  if (l <= 0) {\n    return [];\n  }\n  var res = new Array(l);\n  for(var i = 0; i < l; ++i){\n    res[i] = f(i);\n  }\n  return res;\n}\n\nfunction makeBy(l, f) {\n  return makeByU(l, Curry.__1(f));\n}\n\nfunction makeByAndShuffleU(l, f) {\n  var u = makeByU(l, f);\n  shuffleInPlace(u);\n  return u;\n}\n\nfunction makeByAndShuffle(l, f) {\n  return makeByAndShuffleU(l, Curry.__1(f));\n}\n\nfunction range(start, finish) {\n  var cut = finish - start | 0;\n  if (cut < 0) {\n    return [];\n  }\n  var arr = new Array(cut + 1 | 0);\n  for(var i = 0; i <= cut; ++i){\n    arr[i] = start + i | 0;\n  }\n  return arr;\n}\n\nfunction rangeBy(start, finish, step) {\n  var cut = finish - start | 0;\n  if (cut < 0 || step <= 0) {\n    return [];\n  }\n  var nb = (cut / step | 0) + 1 | 0;\n  var arr = new Array(nb);\n  var cur = start;\n  for(var i = 0; i < nb; ++i){\n    arr[i] = cur;\n    cur = cur + step | 0;\n  }\n  return arr;\n}\n\nfunction zip(xs, ys) {\n  var lenx = xs.length;\n  var leny = ys.length;\n  var len = lenx < leny ? lenx : leny;\n  var s = new Array(len);\n  for(var i = 0; i < len; ++i){\n    s[i] = [\n      xs[i],\n      ys[i]\n    ];\n  }\n  return s;\n}\n\nfunction zipByU(xs, ys, f) {\n  var lenx = xs.length;\n  var leny = ys.length;\n  var len = lenx < leny ? lenx : leny;\n  var s = new Array(len);\n  for(var i = 0; i < len; ++i){\n    s[i] = f(xs[i], ys[i]);\n  }\n  return s;\n}\n\nfunction zipBy(xs, ys, f) {\n  return zipByU(xs, ys, Curry.__2(f));\n}\n\nfunction concat(a1, a2) {\n  var l1 = a1.length;\n  var l2 = a2.length;\n  var a1a2 = new Array(l1 + l2 | 0);\n  for(var i = 0; i < l1; ++i){\n    a1a2[i] = a1[i];\n  }\n  for(var i$1 = 0; i$1 < l2; ++i$1){\n    a1a2[l1 + i$1 | 0] = a2[i$1];\n  }\n  return a1a2;\n}\n\nfunction concatMany(arrs) {\n  var lenArrs = arrs.length;\n  var totalLen = 0;\n  for(var i = 0; i < lenArrs; ++i){\n    totalLen = totalLen + arrs[i].length | 0;\n  }\n  var result = new Array(totalLen);\n  totalLen = 0;\n  for(var j = 0; j < lenArrs; ++j){\n    var cur = arrs[j];\n    for(var k = 0 ,k_finish = cur.length; k < k_finish; ++k){\n      result[totalLen] = cur[k];\n      totalLen = totalLen + 1 | 0;\n    }\n  }\n  return result;\n}\n\nfunction slice(a, offset, len) {\n  if (len <= 0) {\n    return [];\n  }\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var hasLen = lena - ofs | 0;\n  var copyLength = hasLen < len ? hasLen : len;\n  if (copyLength <= 0) {\n    return [];\n  }\n  var result = new Array(copyLength);\n  for(var i = 0; i < copyLength; ++i){\n    result[i] = a[ofs + i | 0];\n  }\n  return result;\n}\n\nfunction sliceToEnd(a, offset) {\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var len = lena - ofs | 0;\n  var result = new Array(len);\n  for(var i = 0; i < len; ++i){\n    result[i] = a[ofs + i | 0];\n  }\n  return result;\n}\n\nfunction fill(a, offset, len, v) {\n  if (len <= 0) {\n    return ;\n  }\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var hasLen = lena - ofs | 0;\n  var fillLength = hasLen < len ? hasLen : len;\n  if (fillLength <= 0) {\n    return ;\n  }\n  for(var i = ofs ,i_finish = ofs + fillLength | 0; i < i_finish; ++i){\n    a[i] = v;\n  }\n  \n}\n\nfunction blitUnsafe(a1, srcofs1, a2, srcofs2, blitLength) {\n  if (srcofs2 <= srcofs1) {\n    for(var j = 0; j < blitLength; ++j){\n      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];\n  }\n  \n}\n\nfunction blit(a1, ofs1, a2, ofs2, len) {\n  var lena1 = a1.length;\n  var lena2 = a2.length;\n  var srcofs1 = ofs1 < 0 ? Caml_primitive.caml_int_max(lena1 + ofs1 | 0, 0) : ofs1;\n  var srcofs2 = ofs2 < 0 ? Caml_primitive.caml_int_max(lena2 + ofs2 | 0, 0) : ofs2;\n  var blitLength = Caml_primitive.caml_int_min(len, Caml_primitive.caml_int_min(lena1 - srcofs1 | 0, lena2 - srcofs2 | 0));\n  if (srcofs2 <= srcofs1) {\n    for(var j = 0; j < blitLength; ++j){\n      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];\n  }\n  \n}\n\nfunction forEachU(a, f) {\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    f(a[i]);\n  }\n  \n}\n\nfunction forEach(a, f) {\n  return forEachU(a, Curry.__1(f));\n}\n\nfunction mapU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  for(var i = 0; i < l; ++i){\n    r[i] = f(a[i]);\n  }\n  return r;\n}\n\nfunction map(a, f) {\n  return mapU(a, Curry.__1(f));\n}\n\nfunction getByU(a, p) {\n  var l = a.length;\n  var i = 0;\n  var r;\n  while(r === undefined && i < l) {\n    var v = a[i];\n    if (p(v)) {\n      r = Caml_option.some(v);\n    }\n    i = i + 1 | 0;\n  };\n  return r;\n}\n\nfunction getBy(a, p) {\n  return getByU(a, Curry.__1(p));\n}\n\nfunction getIndexByU(a, p) {\n  var l = a.length;\n  var i = 0;\n  var r;\n  while(r === undefined && i < l) {\n    var v = a[i];\n    if (p(v)) {\n      r = i;\n    }\n    i = i + 1 | 0;\n  };\n  return r;\n}\n\nfunction getIndexBy(a, p) {\n  return getIndexByU(a, Curry.__1(p));\n}\n\nfunction keepU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    if (f(v)) {\n      r[j] = v;\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keep(a, f) {\n  return keepU(a, Curry.__1(f));\n}\n\nfunction keepWithIndexU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    if (f(v, i)) {\n      r[j] = v;\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keepWithIndex(a, f) {\n  return keepWithIndexU(a, Curry.__2(f));\n}\n\nfunction keepMapU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    var v$1 = f(v);\n    if (v$1 !== undefined) {\n      r[j] = Caml_option.valFromOption(v$1);\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keepMap(a, f) {\n  return keepMapU(a, Curry.__1(f));\n}\n\nfunction forEachWithIndexU(a, f) {\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    f(i, a[i]);\n  }\n  \n}\n\nfunction forEachWithIndex(a, f) {\n  return forEachWithIndexU(a, Curry.__2(f));\n}\n\nfunction mapWithIndexU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  for(var i = 0; i < l; ++i){\n    r[i] = f(i, a[i]);\n  }\n  return r;\n}\n\nfunction mapWithIndex(a, f) {\n  return mapWithIndexU(a, Curry.__2(f));\n}\n\nfunction reduceU(a, x, f) {\n  var r = x;\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    r = f(r, a[i]);\n  }\n  return r;\n}\n\nfunction reduce(a, x, f) {\n  return reduceU(a, x, Curry.__2(f));\n}\n\nfunction reduceReverseU(a, x, f) {\n  var r = x;\n  for(var i = a.length - 1 | 0; i >= 0; --i){\n    r = f(r, a[i]);\n  }\n  return r;\n}\n\nfunction reduceReverse(a, x, f) {\n  return reduceReverseU(a, x, Curry.__2(f));\n}\n\nfunction reduceReverse2U(a, b, x, f) {\n  var r = x;\n  var len = Caml_primitive.caml_int_min(a.length, b.length);\n  for(var i = len - 1 | 0; i >= 0; --i){\n    r = f(r, a[i], b[i]);\n  }\n  return r;\n}\n\nfunction reduceReverse2(a, b, x, f) {\n  return reduceReverse2U(a, b, x, Curry.__3(f));\n}\n\nfunction reduceWithIndexU(a, x, f) {\n  var r = x;\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    r = f(r, a[i], i);\n  }\n  return r;\n}\n\nfunction reduceWithIndex(a, x, f) {\n  return reduceWithIndexU(a, x, Curry.__3(f));\n}\n\nfunction everyU(arr, b) {\n  var len = arr.length;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return true;\n    }\n    if (!b(arr[i])) {\n      return false;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction every(arr, f) {\n  return everyU(arr, Curry.__1(f));\n}\n\nfunction someU(arr, b) {\n  var len = arr.length;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return false;\n    }\n    if (b(arr[i])) {\n      return true;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction some(arr, f) {\n  return someU(arr, Curry.__1(f));\n}\n\nfunction everyAux2(arr1, arr2, _i, b, len) {\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return true;\n    }\n    if (!b(arr1[i], arr2[i])) {\n      return false;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction every2U(a, b, p) {\n  return everyAux2(a, b, 0, p, Caml_primitive.caml_int_min(a.length, b.length));\n}\n\nfunction every2(a, b, p) {\n  return every2U(a, b, Curry.__2(p));\n}\n\nfunction some2U(a, b, p) {\n  var _i = 0;\n  var len = Caml_primitive.caml_int_min(a.length, b.length);\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return false;\n    }\n    if (p(a[i], b[i])) {\n      return true;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction some2(a, b, p) {\n  return some2U(a, b, Curry.__2(p));\n}\n\nfunction eqU(a, b, p) {\n  var lena = a.length;\n  var lenb = b.length;\n  if (lena === lenb) {\n    return everyAux2(a, b, 0, p, lena);\n  } else {\n    return false;\n  }\n}\n\nfunction eq(a, b, p) {\n  return eqU(a, b, Curry.__2(p));\n}\n\nfunction cmpU(a, b, p) {\n  var lena = a.length;\n  var lenb = b.length;\n  if (lena > lenb) {\n    return 1;\n  } else if (lena < lenb) {\n    return -1;\n  } else {\n    var _i = 0;\n    while(true) {\n      var i = _i;\n      if (i === lena) {\n        return 0;\n      }\n      var c = p(a[i], b[i]);\n      if (c !== 0) {\n        return c;\n      }\n      _i = i + 1 | 0;\n      continue ;\n    };\n  }\n}\n\nfunction cmp(a, b, p) {\n  return cmpU(a, b, Curry.__2(p));\n}\n\nfunction partitionU(a, f) {\n  var l = a.length;\n  var i = 0;\n  var j = 0;\n  var a1 = new Array(l);\n  var a2 = new Array(l);\n  for(var ii = 0; ii < l; ++ii){\n    var v = a[ii];\n    if (f(v)) {\n      a1[i] = v;\n      i = i + 1 | 0;\n    } else {\n      a2[j] = v;\n      j = j + 1 | 0;\n    }\n  }\n  a1.length = i;\n  a2.length = j;\n  return [\n          a1,\n          a2\n        ];\n}\n\nfunction partition(a, f) {\n  return partitionU(a, Curry.__1(f));\n}\n\nfunction unzip(a) {\n  var l = a.length;\n  var a1 = new Array(l);\n  var a2 = new Array(l);\n  for(var i = 0; i < l; ++i){\n    var match = a[i];\n    a1[i] = match[0];\n    a2[i] = match[1];\n  }\n  return [\n          a1,\n          a2\n        ];\n}\n\nfunction joinWithU(a, sep, toString) {\n  var l = a.length;\n  if (l === 0) {\n    return \"\";\n  }\n  var lastIndex = l - 1 | 0;\n  var _i = 0;\n  var _res = \"\";\n  while(true) {\n    var res = _res;\n    var i = _i;\n    if (i === lastIndex) {\n      return res + toString(a[i]);\n    }\n    _res = res + (toString(a[i]) + sep);\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction joinWith(a, sep, toString) {\n  return joinWithU(a, sep, Curry.__1(toString));\n}\n\nexports.get = get;\nexports.getExn = getExn;\nexports.set = set;\nexports.setExn = setExn;\nexports.shuffleInPlace = shuffleInPlace;\nexports.shuffle = shuffle;\nexports.reverseInPlace = reverseInPlace;\nexports.reverse = reverse;\nexports.make = make;\nexports.range = range;\nexports.rangeBy = rangeBy;\nexports.makeByU = makeByU;\nexports.makeBy = makeBy;\nexports.makeByAndShuffleU = makeByAndShuffleU;\nexports.makeByAndShuffle = makeByAndShuffle;\nexports.zip = zip;\nexports.zipByU = zipByU;\nexports.zipBy = zipBy;\nexports.unzip = unzip;\nexports.concat = concat;\nexports.concatMany = concatMany;\nexports.slice = slice;\nexports.sliceToEnd = sliceToEnd;\nexports.fill = fill;\nexports.blit = blit;\nexports.blitUnsafe = blitUnsafe;\nexports.forEachU = forEachU;\nexports.forEach = forEach;\nexports.mapU = mapU;\nexports.map = map;\nexports.getByU = getByU;\nexports.getBy = getBy;\nexports.getIndexByU = getIndexByU;\nexports.getIndexBy = getIndexBy;\nexports.keepU = keepU;\nexports.keep = keep;\nexports.keepWithIndexU = keepWithIndexU;\nexports.keepWithIndex = keepWithIndex;\nexports.keepMapU = keepMapU;\nexports.keepMap = keepMap;\nexports.forEachWithIndexU = forEachWithIndexU;\nexports.forEachWithIndex = forEachWithIndex;\nexports.mapWithIndexU = mapWithIndexU;\nexports.mapWithIndex = mapWithIndex;\nexports.partitionU = partitionU;\nexports.partition = partition;\nexports.reduceU = reduceU;\nexports.reduce = reduce;\nexports.reduceReverseU = reduceReverseU;\nexports.reduceReverse = reduceReverse;\nexports.reduceReverse2U = reduceReverse2U;\nexports.reduceReverse2 = reduceReverse2;\nexports.reduceWithIndexU = reduceWithIndexU;\nexports.reduceWithIndex = reduceWithIndex;\nexports.joinWithU = joinWithU;\nexports.joinWith = joinWith;\nexports.someU = someU;\nexports.some = some;\nexports.everyU = everyU;\nexports.every = every;\nexports.every2U = every2U;\nexports.every2 = every2;\nexports.some2U = some2U;\nexports.some2 = some2;\nexports.cmpU = cmpU;\nexports.cmp = cmp;\nexports.eqU = eqU;\nexports.eq = eq;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/belt_Array.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/caml_array.js":
/*!*******************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/caml_array.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n\nfunction caml_array_sub(x, offset, len) {\n  var result = new Array(len);\n  var j = 0;\n  var i = offset;\n  while(j < len) {\n    result[j] = x[i];\n    j = j + 1 | 0;\n    i = i + 1 | 0;\n  };\n  return result;\n}\n\nfunction len(_acc, _l) {\n  while(true) {\n    var l = _l;\n    var acc = _acc;\n    if (!l) {\n      return acc;\n    }\n    _l = l.tl;\n    _acc = l.hd.length + acc | 0;\n    continue ;\n  };\n}\n\nfunction fill(arr, _i, _l) {\n  while(true) {\n    var l = _l;\n    var i = _i;\n    if (!l) {\n      return ;\n    }\n    var x = l.hd;\n    var l$1 = x.length;\n    var k = i;\n    var j = 0;\n    while(j < l$1) {\n      arr[k] = x[j];\n      k = k + 1 | 0;\n      j = j + 1 | 0;\n    };\n    _l = l.tl;\n    _i = k;\n    continue ;\n  };\n}\n\nfunction caml_array_concat(l) {\n  var v = len(0, l);\n  var result = new Array(v);\n  fill(result, 0, l);\n  return result;\n}\n\nfunction set(xs, index, newval) {\n  if (index < 0 || index >= xs.length) {\n    throw {\n          RE_EXN_ID: \"Invalid_argument\",\n          _1: \"index out of bounds\",\n          Error: new Error()\n        };\n  }\n  xs[index] = newval;\n  \n}\n\nfunction get(xs, index) {\n  if (index < 0 || index >= xs.length) {\n    throw {\n          RE_EXN_ID: \"Invalid_argument\",\n          _1: \"index out of bounds\",\n          Error: new Error()\n        };\n  }\n  return xs[index];\n}\n\nfunction caml_make_vect(len, init) {\n  var b = new Array(len);\n  for(var i = 0; i < len; ++i){\n    b[i] = init;\n  }\n  return b;\n}\n\nfunction caml_make_float_vect(len) {\n  var b = new Array(len);\n  for(var i = 0; i < len; ++i){\n    b[i] = 0;\n  }\n  return b;\n}\n\nfunction caml_array_blit(a1, i1, a2, i2, len) {\n  if (i2 <= i1) {\n    for(var j = 0; j < len; ++j){\n      a2[j + i2 | 0] = a1[j + i1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];\n  }\n  \n}\n\nfunction caml_array_dup(prim) {\n  return prim.slice(0);\n}\n\nexports.caml_array_dup = caml_array_dup;\nexports.caml_array_sub = caml_array_sub;\nexports.caml_array_concat = caml_array_concat;\nexports.caml_make_vect = caml_make_vect;\nexports.caml_make_float_vect = caml_make_float_vect;\nexports.caml_array_blit = caml_array_blit;\nexports.get = get;\nexports.set = set;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/caml_array.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/caml_exceptions.js":
/*!************************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/caml_exceptions.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n\nvar id = {\n  contents: 0\n};\n\nfunction create(str) {\n  id.contents = id.contents + 1 | 0;\n  return str + (\"/\" + id.contents);\n}\n\nfunction caml_is_extension(e) {\n  if (e == null) {\n    return false;\n  } else {\n    return typeof e.RE_EXN_ID === \"string\";\n  }\n}\n\nfunction caml_exn_slot_name(x) {\n  return x.RE_EXN_ID;\n}\n\nexports.id = id;\nexports.create = create;\nexports.caml_is_extension = caml_is_extension;\nexports.caml_exn_slot_name = caml_exn_slot_name;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/caml_exceptions.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/caml_format.js":
/*!********************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/caml_format.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar Caml_int64 = __webpack_require__(/*! ./caml_int64.js */ \"./node_modules/bs-platform/lib/js/caml_int64.js\");\n\nfunction parse_digit(c) {\n  if (c >= 65) {\n    if (c >= 97) {\n      if (c >= 123) {\n        return -1;\n      } else {\n        return c - 87 | 0;\n      }\n    } else if (c >= 91) {\n      return -1;\n    } else {\n      return c - 55 | 0;\n    }\n  } else if (c > 57 || c < 48) {\n    return -1;\n  } else {\n    return c - /* \"0\" */48 | 0;\n  }\n}\n\nfunction int_of_string_base(param) {\n  switch (param) {\n    case /* Oct */0 :\n        return 8;\n    case /* Hex */1 :\n        return 16;\n    case /* Dec */2 :\n        return 10;\n    case /* Bin */3 :\n        return 2;\n    \n  }\n}\n\nfunction parse_sign_and_base(s) {\n  var sign = 1;\n  var base = /* Dec */2;\n  var i = 0;\n  var match = s.charCodeAt(i);\n  switch (match) {\n    case 43 :\n        i = i + 1 | 0;\n        break;\n    case 44 :\n        break;\n    case 45 :\n        sign = -1;\n        i = i + 1 | 0;\n        break;\n    default:\n      \n  }\n  if (s[i] === \"0\") {\n    var match$1 = s.charCodeAt(i + 1 | 0);\n    if (match$1 >= 89) {\n      if (match$1 >= 111) {\n        if (match$1 < 121) {\n          switch (match$1 - 111 | 0) {\n            case 0 :\n                base = /* Oct */0;\n                i = i + 2 | 0;\n                break;\n            case 6 :\n                i = i + 2 | 0;\n                break;\n            case 1 :\n            case 2 :\n            case 3 :\n            case 4 :\n            case 5 :\n            case 7 :\n            case 8 :\n                break;\n            case 9 :\n                base = /* Hex */1;\n                i = i + 2 | 0;\n                break;\n            \n          }\n        }\n        \n      } else if (match$1 === 98) {\n        base = /* Bin */3;\n        i = i + 2 | 0;\n      }\n      \n    } else if (match$1 !== 66) {\n      if (match$1 >= 79) {\n        switch (match$1 - 79 | 0) {\n          case 0 :\n              base = /* Oct */0;\n              i = i + 2 | 0;\n              break;\n          case 6 :\n              i = i + 2 | 0;\n              break;\n          case 1 :\n          case 2 :\n          case 3 :\n          case 4 :\n          case 5 :\n          case 7 :\n          case 8 :\n              break;\n          case 9 :\n              base = /* Hex */1;\n              i = i + 2 | 0;\n              break;\n          \n        }\n      }\n      \n    } else {\n      base = /* Bin */3;\n      i = i + 2 | 0;\n    }\n  }\n  return [\n          i,\n          sign,\n          base\n        ];\n}\n\nfunction caml_int_of_string(s) {\n  var match = parse_sign_and_base(s);\n  var i = match[0];\n  var base = int_of_string_base(match[2]);\n  var threshold = 4294967295;\n  var len = s.length;\n  var c = i < len ? s.charCodeAt(i) : /* \"\\000\" */0;\n  var d = parse_digit(c);\n  if (d < 0 || d >= base) {\n    throw {\n          RE_EXN_ID: \"Failure\",\n          _1: \"int_of_string\",\n          Error: new Error()\n        };\n  }\n  var aux = function (_acc, _k) {\n    while(true) {\n      var k = _k;\n      var acc = _acc;\n      if (k === len) {\n        return acc;\n      }\n      var a = s.charCodeAt(k);\n      if (a === /* \"_\" */95) {\n        _k = k + 1 | 0;\n        continue ;\n      }\n      var v = parse_digit(a);\n      if (v < 0 || v >= base) {\n        throw {\n              RE_EXN_ID: \"Failure\",\n              _1: \"int_of_string\",\n              Error: new Error()\n            };\n      }\n      var acc$1 = base * acc + v;\n      if (acc$1 > threshold) {\n        throw {\n              RE_EXN_ID: \"Failure\",\n              _1: \"int_of_string\",\n              Error: new Error()\n            };\n      }\n      _k = k + 1 | 0;\n      _acc = acc$1;\n      continue ;\n    };\n  };\n  var res = match[1] * aux(d, i + 1 | 0);\n  var or_res = res | 0;\n  if (base === 10 && res !== or_res) {\n    throw {\n          RE_EXN_ID: \"Failure\",\n          _1: \"int_of_string\",\n          Error: new Error()\n        };\n  }\n  return or_res;\n}\n\nfunction caml_int64_of_string(s) {\n  var match = parse_sign_and_base(s);\n  var hbase = match[2];\n  var i = match[0];\n  var base = Caml_int64.of_int32(int_of_string_base(hbase));\n  var sign = Caml_int64.of_int32(match[1]);\n  var threshold;\n  switch (hbase) {\n    case /* Oct */0 :\n        threshold = Caml_int64.mk(-1, 536870911);\n        break;\n    case /* Hex */1 :\n        threshold = Caml_int64.mk(-1, 268435455);\n        break;\n    case /* Dec */2 :\n        threshold = Caml_int64.mk(-1717986919, 429496729);\n        break;\n    case /* Bin */3 :\n        threshold = Caml_int64.max_int;\n        break;\n    \n  }\n  var len = s.length;\n  var c = i < len ? s.charCodeAt(i) : /* \"\\000\" */0;\n  var d = Caml_int64.of_int32(parse_digit(c));\n  if (Caml_int64.lt(d, Caml_int64.zero) || Caml_int64.ge(d, base)) {\n    throw {\n          RE_EXN_ID: \"Failure\",\n          _1: \"int64_of_string\",\n          Error: new Error()\n        };\n  }\n  var aux = function (_acc, _k) {\n    while(true) {\n      var k = _k;\n      var acc = _acc;\n      if (k === len) {\n        return acc;\n      }\n      var a = s.charCodeAt(k);\n      if (a === /* \"_\" */95) {\n        _k = k + 1 | 0;\n        continue ;\n      }\n      var v = Caml_int64.of_int32(parse_digit(a));\n      if (Caml_int64.lt(v, Caml_int64.zero) || Caml_int64.ge(v, base) || Caml_int64.gt(acc, threshold)) {\n        throw {\n              RE_EXN_ID: \"Failure\",\n              _1: \"int64_of_string\",\n              Error: new Error()\n            };\n      }\n      var acc$1 = Caml_int64.add(Caml_int64.mul(base, acc), v);\n      _k = k + 1 | 0;\n      _acc = acc$1;\n      continue ;\n    };\n  };\n  var res = Caml_int64.mul(sign, aux(d, i + 1 | 0));\n  var or_res = Caml_int64.or_(res, Caml_int64.zero);\n  if (Caml_int64.eq(base, Caml_int64.mk(10, 0)) && Caml_int64.neq(res, or_res)) {\n    throw {\n          RE_EXN_ID: \"Failure\",\n          _1: \"int64_of_string\",\n          Error: new Error()\n        };\n  }\n  return or_res;\n}\n\nfunction int_of_base(param) {\n  switch (param) {\n    case /* Oct */0 :\n        return 8;\n    case /* Hex */1 :\n        return 16;\n    case /* Dec */2 :\n        return 10;\n    \n  }\n}\n\nfunction lowercase(c) {\n  if (c >= /* \"A\" */65 && c <= /* \"Z\" */90 || c >= /* \"\\192\" */192 && c <= /* \"\\214\" */214 || c >= /* \"\\216\" */216 && c <= /* \"\\222\" */222) {\n    return c + 32 | 0;\n  } else {\n    return c;\n  }\n}\n\nfunction parse_format(fmt) {\n  var len = fmt.length;\n  if (len > 31) {\n    throw {\n          RE_EXN_ID: \"Invalid_argument\",\n          _1: \"format_int: format too long\",\n          Error: new Error()\n        };\n  }\n  var f = {\n    justify: \"+\",\n    signstyle: \"-\",\n    filter: \" \",\n    alternate: false,\n    base: /* Dec */2,\n    signedconv: false,\n    width: 0,\n    uppercase: false,\n    sign: 1,\n    prec: -1,\n    conv: \"f\"\n  };\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i >= len) {\n      return f;\n    }\n    var c = fmt.charCodeAt(i);\n    var exit = 0;\n    if (c >= 69) {\n      if (c >= 88) {\n        if (c >= 121) {\n          exit = 1;\n        } else {\n          switch (c - 88 | 0) {\n            case 0 :\n                f.base = /* Hex */1;\n                f.uppercase = true;\n                _i = i + 1 | 0;\n                continue ;\n            case 13 :\n            case 14 :\n            case 15 :\n                exit = 5;\n                break;\n            case 12 :\n            case 17 :\n                exit = 4;\n                break;\n            case 23 :\n                f.base = /* Oct */0;\n                _i = i + 1 | 0;\n                continue ;\n            case 29 :\n                f.base = /* Dec */2;\n                _i = i + 1 | 0;\n                continue ;\n            case 1 :\n            case 2 :\n            case 3 :\n            case 4 :\n            case 5 :\n            case 6 :\n            case 7 :\n            case 8 :\n            case 9 :\n            case 10 :\n            case 11 :\n            case 16 :\n            case 18 :\n            case 19 :\n            case 20 :\n            case 21 :\n            case 22 :\n            case 24 :\n            case 25 :\n            case 26 :\n            case 27 :\n            case 28 :\n            case 30 :\n            case 31 :\n                exit = 1;\n                break;\n            case 32 :\n                f.base = /* Hex */1;\n                _i = i + 1 | 0;\n                continue ;\n            \n          }\n        }\n      } else if (c >= 72) {\n        exit = 1;\n      } else {\n        f.signedconv = true;\n        f.uppercase = true;\n        f.conv = String.fromCharCode(lowercase(c));\n        _i = i + 1 | 0;\n        continue ;\n      }\n    } else {\n      switch (c) {\n        case 35 :\n            f.alternate = true;\n            _i = i + 1 | 0;\n            continue ;\n        case 32 :\n        case 43 :\n            exit = 2;\n            break;\n        case 45 :\n            f.justify = \"-\";\n            _i = i + 1 | 0;\n            continue ;\n        case 46 :\n            f.prec = 0;\n            var j = i + 1 | 0;\n            while((function(j){\n                return function () {\n                  var w = fmt.charCodeAt(j) - /* \"0\" */48 | 0;\n                  return w >= 0 && w <= 9;\n                }\n                }(j))()) {\n              f.prec = (Math.imul(f.prec, 10) + fmt.charCodeAt(j) | 0) - /* \"0\" */48 | 0;\n              j = j + 1 | 0;\n            };\n            _i = j;\n            continue ;\n        case 33 :\n        case 34 :\n        case 36 :\n        case 37 :\n        case 38 :\n        case 39 :\n        case 40 :\n        case 41 :\n        case 42 :\n        case 44 :\n        case 47 :\n            exit = 1;\n            break;\n        case 48 :\n            f.filter = \"0\";\n            _i = i + 1 | 0;\n            continue ;\n        case 49 :\n        case 50 :\n        case 51 :\n        case 52 :\n        case 53 :\n        case 54 :\n        case 55 :\n        case 56 :\n        case 57 :\n            exit = 3;\n            break;\n        default:\n          exit = 1;\n      }\n    }\n    switch (exit) {\n      case 1 :\n          _i = i + 1 | 0;\n          continue ;\n      case 2 :\n          f.signstyle = String.fromCharCode(c);\n          _i = i + 1 | 0;\n          continue ;\n      case 3 :\n          f.width = 0;\n          var j$1 = i;\n          while((function(j$1){\n              return function () {\n                var w = fmt.charCodeAt(j$1) - /* \"0\" */48 | 0;\n                return w >= 0 && w <= 9;\n              }\n              }(j$1))()) {\n            f.width = (Math.imul(f.width, 10) + fmt.charCodeAt(j$1) | 0) - /* \"0\" */48 | 0;\n            j$1 = j$1 + 1 | 0;\n          };\n          _i = j$1;\n          continue ;\n      case 4 :\n          f.signedconv = true;\n          f.base = /* Dec */2;\n          _i = i + 1 | 0;\n          continue ;\n      case 5 :\n          f.signedconv = true;\n          f.conv = String.fromCharCode(c);\n          _i = i + 1 | 0;\n          continue ;\n      \n    }\n  };\n}\n\nfunction finish_formatting(config, rawbuffer) {\n  var justify = config.justify;\n  var signstyle = config.signstyle;\n  var filter = config.filter;\n  var alternate = config.alternate;\n  var base = config.base;\n  var signedconv = config.signedconv;\n  var width = config.width;\n  var uppercase = config.uppercase;\n  var sign = config.sign;\n  var len = rawbuffer.length;\n  if (signedconv && (sign < 0 || signstyle !== \"-\")) {\n    len = len + 1 | 0;\n  }\n  if (alternate) {\n    if (base === /* Oct */0) {\n      len = len + 1 | 0;\n    } else if (base === /* Hex */1) {\n      len = len + 2 | 0;\n    }\n    \n  }\n  var buffer = \"\";\n  if (justify === \"+\" && filter === \" \") {\n    for(var _for = len; _for < width; ++_for){\n      buffer = buffer + filter;\n    }\n  }\n  if (signedconv) {\n    if (sign < 0) {\n      buffer = buffer + \"-\";\n    } else if (signstyle !== \"-\") {\n      buffer = buffer + signstyle;\n    }\n    \n  }\n  if (alternate && base === /* Oct */0) {\n    buffer = buffer + \"0\";\n  }\n  if (alternate && base === /* Hex */1) {\n    buffer = buffer + \"0x\";\n  }\n  if (justify === \"+\" && filter === \"0\") {\n    for(var _for$1 = len; _for$1 < width; ++_for$1){\n      buffer = buffer + filter;\n    }\n  }\n  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;\n  if (justify === \"-\") {\n    for(var _for$2 = len; _for$2 < width; ++_for$2){\n      buffer = buffer + \" \";\n    }\n  }\n  return buffer;\n}\n\nfunction caml_format_int(fmt, i) {\n  if (fmt === \"%d\") {\n    return String(i);\n  }\n  var f = parse_format(fmt);\n  var i$1 = i < 0 ? (\n      f.signedconv ? (f.sign = -1, -i) : (i >>> 0)\n    ) : i;\n  var s = i$1.toString(int_of_base(f.base));\n  if (f.prec >= 0) {\n    f.filter = \" \";\n    var n = f.prec - s.length | 0;\n    if (n > 0) {\n      s = \"0\".repeat(n) + s;\n    }\n    \n  }\n  return finish_formatting(f, s);\n}\n\nfunction dec_of_pos_int64(x) {\n  if (!Caml_int64.lt(x, Caml_int64.zero)) {\n    return Caml_int64.to_string(x);\n  }\n  var wbase = Caml_int64.mk(10, 0);\n  var y = Caml_int64.discard_sign(x);\n  var match = Caml_int64.div_mod(y, wbase);\n  var match$1 = Caml_int64.div_mod(Caml_int64.add(Caml_int64.mk(8, 0), match[1]), wbase);\n  var quotient = Caml_int64.add(Caml_int64.add(Caml_int64.mk(-858993460, 214748364), match[0]), match$1[0]);\n  return Caml_int64.to_string(quotient) + \"0123456789\"[Caml_int64.to_int32(match$1[1])];\n}\n\nfunction oct_of_int64(x) {\n  var s = \"\";\n  var wbase = Caml_int64.mk(8, 0);\n  var cvtbl = \"01234567\";\n  if (Caml_int64.lt(x, Caml_int64.zero)) {\n    var y = Caml_int64.discard_sign(x);\n    var match = Caml_int64.div_mod(y, wbase);\n    var quotient = Caml_int64.add(Caml_int64.mk(0, 268435456), match[0]);\n    var modulus = match[1];\n    s = cvtbl[Caml_int64.to_int32(modulus)] + s;\n    while(Caml_int64.neq(quotient, Caml_int64.zero)) {\n      var match$1 = Caml_int64.div_mod(quotient, wbase);\n      quotient = match$1[0];\n      modulus = match$1[1];\n      s = cvtbl[Caml_int64.to_int32(modulus)] + s;\n    };\n  } else {\n    var match$2 = Caml_int64.div_mod(x, wbase);\n    var quotient$1 = match$2[0];\n    var modulus$1 = match$2[1];\n    s = cvtbl[Caml_int64.to_int32(modulus$1)] + s;\n    while(Caml_int64.neq(quotient$1, Caml_int64.zero)) {\n      var match$3 = Caml_int64.div_mod(quotient$1, wbase);\n      quotient$1 = match$3[0];\n      modulus$1 = match$3[1];\n      s = cvtbl[Caml_int64.to_int32(modulus$1)] + s;\n    };\n  }\n  return s;\n}\n\nfunction caml_int64_format(fmt, x) {\n  if (fmt === \"%d\") {\n    return Caml_int64.to_string(x);\n  }\n  var f = parse_format(fmt);\n  var x$1 = f.signedconv && Caml_int64.lt(x, Caml_int64.zero) ? (f.sign = -1, Caml_int64.neg(x)) : x;\n  var match = f.base;\n  var s;\n  switch (match) {\n    case /* Oct */0 :\n        s = oct_of_int64(x$1);\n        break;\n    case /* Hex */1 :\n        s = Caml_int64.to_hex(x$1);\n        break;\n    case /* Dec */2 :\n        s = dec_of_pos_int64(x$1);\n        break;\n    \n  }\n  var fill_s;\n  if (f.prec >= 0) {\n    f.filter = \" \";\n    var n = f.prec - s.length | 0;\n    fill_s = n > 0 ? \"0\".repeat(n) + s : s;\n  } else {\n    fill_s = s;\n  }\n  return finish_formatting(f, fill_s);\n}\n\nfunction caml_format_float(fmt, x) {\n  var f = parse_format(fmt);\n  var prec = f.prec < 0 ? 6 : f.prec;\n  var x$1 = x < 0 ? (f.sign = -1, -x) : x;\n  var s = \"\";\n  if (isNaN(x$1)) {\n    s = \"nan\";\n    f.filter = \" \";\n  } else if (isFinite(x$1)) {\n    var match = f.conv;\n    switch (match) {\n      case \"e\" :\n          s = x$1.toExponential(prec);\n          var i = s.length;\n          if (s[i - 3 | 0] === \"e\") {\n            s = s.slice(0, i - 1 | 0) + (\"0\" + s.slice(i - 1 | 0));\n          }\n          break;\n      case \"f\" :\n          s = x$1.toFixed(prec);\n          break;\n      case \"g\" :\n          var prec$1 = prec !== 0 ? prec : 1;\n          s = x$1.toExponential(prec$1 - 1 | 0);\n          var j = s.indexOf(\"e\");\n          var exp = Number(s.slice(j + 1 | 0)) | 0;\n          if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {\n            var i$1 = j - 1 | 0;\n            while(s[i$1] === \"0\") {\n              i$1 = i$1 - 1 | 0;\n            };\n            if (s[i$1] === \".\") {\n              i$1 = i$1 - 1 | 0;\n            }\n            s = s.slice(0, i$1 + 1 | 0) + s.slice(j);\n            var i$2 = s.length;\n            if (s[i$2 - 3 | 0] === \"e\") {\n              s = s.slice(0, i$2 - 1 | 0) + (\"0\" + s.slice(i$2 - 1 | 0));\n            }\n            \n          } else {\n            var p = prec$1;\n            if (exp < 0) {\n              p = p - (exp + 1 | 0) | 0;\n              s = x$1.toFixed(p);\n            } else {\n              while((function () {\n                      s = x$1.toFixed(p);\n                      return s.length > (prec$1 + 1 | 0);\n                    })()) {\n                p = p - 1 | 0;\n              };\n            }\n            if (p !== 0) {\n              var k = s.length - 1 | 0;\n              while(s[k] === \"0\") {\n                k = k - 1 | 0;\n              };\n              if (s[k] === \".\") {\n                k = k - 1 | 0;\n              }\n              s = s.slice(0, k + 1 | 0);\n            }\n            \n          }\n          break;\n      default:\n        \n    }\n  } else {\n    s = \"inf\";\n    f.filter = \" \";\n  }\n  return finish_formatting(f, s);\n}\n\nvar caml_hexstring_of_float = (function(x,prec,style){\n  if (!isFinite(x)) {\n    if (isNaN(x)) return \"nan\";\n    return x > 0 ? \"infinity\":\"-infinity\";\n  }\n  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;\n  if(sign) x = -x;\n  var exp = 0;\n  if (x == 0) { }\n  else if (x < 1) {\n    while (x < 1 && exp > -1022)  { x *= 2; exp-- }\n  } else {\n    while (x >= 2) { x /= 2; exp++ }\n  }\n  var exp_sign = exp < 0 ? '' : '+';\n  var sign_str = '';\n  if (sign) sign_str = '-'\n  else {\n    switch(style){\n    case 43 /* '+' */: sign_str = '+'; break;\n    case 32 /* ' ' */: sign_str = ' '; break;\n    default: break;\n    }\n  }\n  if (prec >= 0 && prec < 13) {\n    /* If a precision is given, and is small, round mantissa accordingly */\n      var cst = Math.pow(2,prec * 4);\n      x = Math.round(x * cst) / cst;\n  }\n  var x_str = x.toString(16);\n  if(prec >= 0){\n      var idx = x_str.indexOf('.');\n    if(idx<0) {\n      x_str += '.' +  '0'.repeat(prec);\n    }\n    else {\n      var size = idx+1+prec;\n      if(x_str.length < size)\n        x_str += '0'.repeat(size - x_str.length);\n      else\n        x_str = x_str.substr(0,size);\n    }\n  }\n  return  (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));\n});\n\nvar float_of_string = (function(s,exn){\n\n    var res = +s;\n    if ((s.length > 0) && (res === res))\n        return res;\n    s = s.replace(/_/g, \"\");\n    res = +s;\n    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {\n        return res;\n    };\n    var m = /^ *([+-]?)0x([0-9a-f]+)\\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);\n    //            1        2             3           4\n    if(m){\n        var m3 = m[3].replace(/0+$/,'');\n        var mantissa = parseInt(m[1] + m[2] + m3, 16);\n        var exponent = (m[4]|0) - 4*m3.length;\n        res = mantissa * Math.pow(2, exponent);\n        return res;\n    }\n    if (/^\\+?inf(inity)?$/i.test(s))\n        return Infinity;\n    if (/^-inf(inity)?$/i.test(s))\n        return -Infinity;\n    throw exn;\n});\n\nfunction caml_float_of_string(s) {\n  return float_of_string(s, {\n              RE_EXN_ID: \"Failure\",\n              _1: \"float_of_string\"\n            });\n}\n\nvar caml_nativeint_format = caml_format_int;\n\nvar caml_int32_format = caml_format_int;\n\nvar caml_int32_of_string = caml_int_of_string;\n\nvar caml_nativeint_of_string = caml_int_of_string;\n\nexports.caml_format_float = caml_format_float;\nexports.caml_hexstring_of_float = caml_hexstring_of_float;\nexports.caml_format_int = caml_format_int;\nexports.caml_nativeint_format = caml_nativeint_format;\nexports.caml_int32_format = caml_int32_format;\nexports.caml_float_of_string = caml_float_of_string;\nexports.caml_int64_format = caml_int64_format;\nexports.caml_int_of_string = caml_int_of_string;\nexports.caml_int32_of_string = caml_int32_of_string;\nexports.caml_int64_of_string = caml_int64_of_string;\nexports.caml_nativeint_of_string = caml_nativeint_of_string;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/caml_format.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/caml_int64.js":
/*!*******************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/caml_int64.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar Caml_primitive = __webpack_require__(/*! ./caml_primitive.js */ \"./node_modules/bs-platform/lib/js/caml_primitive.js\");\n\nfunction mk(lo, hi) {\n  return [\n          hi,\n          (lo >>> 0)\n        ];\n}\n\nvar min_int = [\n  -2147483648,\n  0\n];\n\nvar max_int = [\n  2147483647,\n  4294967295\n];\n\nvar one = [\n  0,\n  1\n];\n\nvar zero = [\n  0,\n  0\n];\n\nvar neg_one = [\n  -1,\n  4294967295\n];\n\nfunction neg_signed(x) {\n  return (x & 2147483648) !== 0;\n}\n\nfunction non_neg_signed(x) {\n  return (x & 2147483648) === 0;\n}\n\nfunction succ(param) {\n  var x_lo = param[1];\n  var x_hi = param[0];\n  var lo = x_lo + 1 | 0;\n  return mk(lo, x_hi + (\n              lo === 0 ? 1 : 0\n            ) | 0);\n}\n\nfunction neg(param) {\n  var other_lo = (param[1] ^ -1) + 1 | 0;\n  return mk(other_lo, (param[0] ^ -1) + (\n              other_lo === 0 ? 1 : 0\n            ) | 0);\n}\n\nfunction add_aux(param, y_lo, y_hi) {\n  var x_lo = param[1];\n  var lo = x_lo + y_lo | 0;\n  var overflow = neg_signed(x_lo) && (neg_signed(y_lo) || non_neg_signed(lo)) || neg_signed(y_lo) && non_neg_signed(lo) ? 1 : 0;\n  return mk(lo, param[0] + y_hi + overflow | 0);\n}\n\nfunction add(self, param) {\n  return add_aux(self, param[1], param[0]);\n}\n\nfunction eq(x, y) {\n  if (x[0] === y[0]) {\n    return x[1] === y[1];\n  } else {\n    return false;\n  }\n}\n\nfunction equal_null(x, y) {\n  if (y !== null) {\n    return eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_undefined(x, y) {\n  if (y !== undefined) {\n    return eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_nullable(x, y) {\n  if (y == null) {\n    return false;\n  } else {\n    return eq(x, y);\n  }\n}\n\nfunction sub_aux(x, lo, hi) {\n  var y_lo = ((lo ^ -1) + 1 >>> 0);\n  var y_hi = (hi ^ -1) + (\n    y_lo === 0 ? 1 : 0\n  ) | 0;\n  return add_aux(x, y_lo, y_hi);\n}\n\nfunction sub(self, param) {\n  return sub_aux(self, param[1], param[0]);\n}\n\nfunction lsl_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  }\n  var lo = x[1];\n  if (numBits >= 32) {\n    return mk(0, (lo << (numBits - 32 | 0)));\n  } else {\n    return mk((lo << numBits), (lo >>> (32 - numBits | 0)) | (x[0] << numBits));\n  }\n}\n\nfunction lsr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  }\n  var hi = x[0];\n  var offset = numBits - 32 | 0;\n  if (offset === 0) {\n    return mk(hi, 0);\n  } else if (offset > 0) {\n    return mk((hi >>> offset), 0);\n  } else {\n    return mk((hi << (-offset | 0)) | (x[1] >>> numBits), (hi >>> numBits));\n  }\n}\n\nfunction asr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  }\n  var hi = x[0];\n  if (numBits < 32) {\n    return mk((hi << (32 - numBits | 0)) | (x[1] >>> numBits), (hi >> numBits));\n  } else {\n    return mk((hi >> (numBits - 32 | 0)), hi >= 0 ? 0 : -1);\n  }\n}\n\nfunction is_zero(param) {\n  if (param[0] !== 0 || param[1] !== 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction mul(_this, _other) {\n  while(true) {\n    var other = _other;\n    var $$this = _this;\n    var lo;\n    var this_hi = $$this[0];\n    var exit = 0;\n    var exit$1 = 0;\n    var exit$2 = 0;\n    if (this_hi !== 0) {\n      exit$2 = 4;\n    } else {\n      if ($$this[1] === 0) {\n        return zero;\n      }\n      exit$2 = 4;\n    }\n    if (exit$2 === 4) {\n      if (other[0] !== 0) {\n        exit$1 = 3;\n      } else {\n        if (other[1] === 0) {\n          return zero;\n        }\n        exit$1 = 3;\n      }\n    }\n    if (exit$1 === 3) {\n      if (this_hi !== -2147483648 || $$this[1] !== 0) {\n        exit = 2;\n      } else {\n        lo = other[1];\n      }\n    }\n    if (exit === 2) {\n      var other_hi = other[0];\n      var lo$1 = $$this[1];\n      var exit$3 = 0;\n      if (other_hi !== -2147483648 || other[1] !== 0) {\n        exit$3 = 3;\n      } else {\n        lo = lo$1;\n      }\n      if (exit$3 === 3) {\n        var other_lo = other[1];\n        if (this_hi < 0) {\n          if (other_hi >= 0) {\n            return neg(mul(neg($$this), other));\n          }\n          _other = neg(other);\n          _this = neg($$this);\n          continue ;\n        }\n        if (other_hi < 0) {\n          return neg(mul($$this, neg(other)));\n        }\n        var a48 = (this_hi >>> 16);\n        var a32 = this_hi & 65535;\n        var a16 = (lo$1 >>> 16);\n        var a00 = lo$1 & 65535;\n        var b48 = (other_hi >>> 16);\n        var b32 = other_hi & 65535;\n        var b16 = (other_lo >>> 16);\n        var b00 = other_lo & 65535;\n        var c48 = 0;\n        var c32 = 0;\n        var c16 = 0;\n        var c00 = a00 * b00;\n        c16 = (c00 >>> 16) + a16 * b00;\n        c32 = (c16 >>> 16);\n        c16 = (c16 & 65535) + a00 * b16;\n        c32 = c32 + (c16 >>> 16) + a32 * b00;\n        c48 = (c32 >>> 16);\n        c32 = (c32 & 65535) + a16 * b16;\n        c48 = c48 + (c32 >>> 16);\n        c32 = (c32 & 65535) + a00 * b32;\n        c48 = c48 + (c32 >>> 16);\n        c32 = c32 & 65535;\n        c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;\n        return mk(c00 & 65535 | ((c16 & 65535) << 16), c32 | (c48 << 16));\n      }\n      \n    }\n    if ((lo & 1) === 0) {\n      return zero;\n    } else {\n      return min_int;\n    }\n  };\n}\n\nfunction xor(param, param$1) {\n  return mk(param[1] ^ param$1[1], param[0] ^ param$1[0]);\n}\n\nfunction or_(param, param$1) {\n  return mk(param[1] | param$1[1], param[0] | param$1[0]);\n}\n\nfunction and_(param, param$1) {\n  return mk(param[1] & param$1[1], param[0] & param$1[0]);\n}\n\nfunction ge(param, param$1) {\n  var other_hi = param$1[0];\n  var hi = param[0];\n  if (hi > other_hi) {\n    return true;\n  } else if (hi < other_hi) {\n    return false;\n  } else {\n    return param[1] >= param$1[1];\n  }\n}\n\nfunction neq(x, y) {\n  return !eq(x, y);\n}\n\nfunction lt(x, y) {\n  return !ge(x, y);\n}\n\nfunction gt(x, y) {\n  if (x[0] > y[0]) {\n    return true;\n  } else if (x[0] < y[0]) {\n    return false;\n  } else {\n    return x[1] > y[1];\n  }\n}\n\nfunction le(x, y) {\n  return !gt(x, y);\n}\n\nfunction min(x, y) {\n  if (ge(x, y)) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction max(x, y) {\n  if (gt(x, y)) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction to_float(param) {\n  return param[0] * 0x100000000 + param[1];\n}\n\nfunction of_float(x) {\n  if (isNaN(x) || !isFinite(x)) {\n    return zero;\n  } else if (x <= -9.22337203685477581e+18) {\n    return min_int;\n  } else if (x + 1 >= 9.22337203685477581e+18) {\n    return max_int;\n  } else if (x < 0) {\n    return neg(of_float(-x));\n  } else {\n    return mk(x % 4294967296 | 0, x / 4294967296 | 0);\n  }\n}\n\nfunction isSafeInteger(param) {\n  var hi = param[0];\n  var top11Bits = (hi >> 21);\n  if (top11Bits === 0) {\n    return true;\n  } else if (top11Bits === -1) {\n    return !(param[1] === 0 && hi === (4292870144 | 0));\n  } else {\n    return false;\n  }\n}\n\nfunction to_string(self) {\n  if (isSafeInteger(self)) {\n    return String(to_float(self));\n  }\n  if (self[0] < 0) {\n    if (eq(self, min_int)) {\n      return \"-9223372036854775808\";\n    } else {\n      return \"-\" + to_string(neg(self));\n    }\n  }\n  var approx_div1 = of_float(Math.floor(to_float(self) / 10));\n  var lo = approx_div1[1];\n  var hi = approx_div1[0];\n  var match = sub_aux(sub_aux(self, (lo << 3), (lo >>> 29) | (hi << 3)), (lo << 1), (lo >>> 31) | (hi << 1));\n  var rem_lo = match[1];\n  var rem_hi = match[0];\n  if (rem_lo === 0 && rem_hi === 0) {\n    return to_string(approx_div1) + \"0\";\n  }\n  if (rem_hi < 0) {\n    var rem_lo$1 = ((rem_lo ^ -1) + 1 >>> 0);\n    var delta = Math.ceil(rem_lo$1 / 10);\n    var remainder = 10 * delta - rem_lo$1;\n    return to_string(sub_aux(approx_div1, delta | 0, 0)) + String(remainder | 0);\n  }\n  var rem_lo$2 = rem_lo;\n  var delta$1 = Math.floor(rem_lo$2 / 10);\n  var remainder$1 = rem_lo$2 - 10 * delta$1;\n  return to_string(add_aux(approx_div1, delta$1 | 0, 0)) + String(remainder$1 | 0);\n}\n\nfunction div(_self, _other) {\n  while(true) {\n    var other = _other;\n    var self = _self;\n    var self_hi = self[0];\n    var exit = 0;\n    var exit$1 = 0;\n    if (other[0] !== 0 || other[1] !== 0) {\n      exit$1 = 2;\n    } else {\n      throw {\n            RE_EXN_ID: \"Division_by_zero\",\n            Error: new Error()\n          };\n    }\n    if (exit$1 === 2) {\n      if (self_hi !== -2147483648) {\n        if (self_hi !== 0) {\n          exit = 1;\n        } else {\n          if (self[1] === 0) {\n            return zero;\n          }\n          exit = 1;\n        }\n      } else if (self[1] !== 0) {\n        exit = 1;\n      } else {\n        if (eq(other, one) || eq(other, neg_one)) {\n          return self;\n        }\n        if (eq(other, min_int)) {\n          return one;\n        }\n        var half_this = asr_(self, 1);\n        var approx = lsl_(div(half_this, other), 1);\n        var exit$2 = 0;\n        if (approx[0] !== 0) {\n          exit$2 = 3;\n        } else {\n          if (approx[1] === 0) {\n            if (other[0] < 0) {\n              return one;\n            } else {\n              return neg(one);\n            }\n          }\n          exit$2 = 3;\n        }\n        if (exit$2 === 3) {\n          var rem = sub(self, mul(other, approx));\n          return add(approx, div(rem, other));\n        }\n        \n      }\n    }\n    if (exit === 1) {\n      var other_hi = other[0];\n      var exit$3 = 0;\n      if (other_hi !== -2147483648) {\n        exit$3 = 2;\n      } else {\n        if (other[1] === 0) {\n          return zero;\n        }\n        exit$3 = 2;\n      }\n      if (exit$3 === 2) {\n        if (self_hi < 0) {\n          if (other_hi >= 0) {\n            return neg(div(neg(self), other));\n          }\n          _other = neg(other);\n          _self = neg(self);\n          continue ;\n        }\n        if (other_hi < 0) {\n          return neg(div(self, neg(other)));\n        }\n        var res = zero;\n        var rem$1 = self;\n        while(ge(rem$1, other)) {\n          var approx$1 = Caml_primitive.caml_float_max(1, Math.floor(to_float(rem$1) / to_float(other)));\n          var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);\n          var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n          var approxRes = of_float(approx$1);\n          var approxRem = mul(approxRes, other);\n          while(approxRem[0] < 0 || gt(approxRem, rem$1)) {\n            approx$1 = approx$1 - delta;\n            approxRes = of_float(approx$1);\n            approxRem = mul(approxRes, other);\n          };\n          if (is_zero(approxRes)) {\n            approxRes = one;\n          }\n          res = add(res, approxRes);\n          rem$1 = sub(rem$1, approxRem);\n        };\n        return res;\n      }\n      \n    }\n    \n  };\n}\n\nfunction mod_(self, other) {\n  return sub(self, mul(div(self, other), other));\n}\n\nfunction div_mod(self, other) {\n  var quotient = div(self, other);\n  return [\n          quotient,\n          sub(self, mul(quotient, other))\n        ];\n}\n\nfunction compare(self, other) {\n  var v = Caml_primitive.caml_nativeint_compare(self[0], other[0]);\n  if (v === 0) {\n    return Caml_primitive.caml_nativeint_compare(self[1], other[1]);\n  } else {\n    return v;\n  }\n}\n\nfunction of_int32(lo) {\n  return mk(lo, lo < 0 ? -1 : 0);\n}\n\nfunction to_int32(x) {\n  return x[1] | 0;\n}\n\nfunction to_hex(x) {\n  var x_lo = x[1];\n  var x_hi = x[0];\n  var aux = function (v) {\n    return (v >>> 0).toString(16);\n  };\n  if (x_hi === 0 && x_lo === 0) {\n    return \"0\";\n  }\n  if (x_lo === 0) {\n    return aux(x_hi) + \"00000000\";\n  }\n  if (x_hi === 0) {\n    return aux(x_lo);\n  }\n  var lo = aux(x_lo);\n  var pad = 8 - lo.length | 0;\n  if (pad <= 0) {\n    return aux(x_hi) + lo;\n  } else {\n    return aux(x_hi) + (\"0\".repeat(pad) + lo);\n  }\n}\n\nfunction discard_sign(x) {\n  return [\n          2147483647 & x[0],\n          x[1]\n        ];\n}\n\nfunction float_of_bits(x) {\n  return (function(lo,hi){ return (new Float64Array(new Int32Array([lo,hi]).buffer))[0]})(x[1], x[0]);\n}\n\nfunction bits_of_float(x) {\n  var match = (function(x){return new Int32Array(new Float64Array([x]).buffer)})(x);\n  return mk(match[0], match[1]);\n}\n\nexports.mk = mk;\nexports.succ = succ;\nexports.min_int = min_int;\nexports.max_int = max_int;\nexports.one = one;\nexports.zero = zero;\nexports.neg_one = neg_one;\nexports.of_int32 = of_int32;\nexports.to_int32 = to_int32;\nexports.add = add;\nexports.neg = neg;\nexports.sub = sub;\nexports.lsl_ = lsl_;\nexports.lsr_ = lsr_;\nexports.asr_ = asr_;\nexports.is_zero = is_zero;\nexports.mul = mul;\nexports.xor = xor;\nexports.or_ = or_;\nexports.and_ = and_;\nexports.ge = ge;\nexports.eq = eq;\nexports.neq = neq;\nexports.lt = lt;\nexports.gt = gt;\nexports.le = le;\nexports.equal_null = equal_null;\nexports.equal_undefined = equal_undefined;\nexports.equal_nullable = equal_nullable;\nexports.min = min;\nexports.max = max;\nexports.to_float = to_float;\nexports.of_float = of_float;\nexports.div = div;\nexports.mod_ = mod_;\nexports.compare = compare;\nexports.float_of_bits = float_of_bits;\nexports.bits_of_float = bits_of_float;\nexports.div_mod = div_mod;\nexports.to_hex = to_hex;\nexports.discard_sign = discard_sign;\nexports.to_string = to_string;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/caml_int64.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/caml_option.js":
/*!********************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/caml_option.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n\nfunction isNested(x) {\n  return x.BS_PRIVATE_NESTED_SOME_NONE !== undefined;\n}\n\nfunction some(x) {\n  if (x === undefined) {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: 0\n          };\n  } else if (x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: x.BS_PRIVATE_NESTED_SOME_NONE + 1 | 0\n          };\n  } else {\n    return x;\n  }\n}\n\nfunction nullable_to_opt(x) {\n  if (x == null) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction undefined_to_opt(x) {\n  if (x === undefined) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction null_to_opt(x) {\n  if (x === null) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction valFromOption(x) {\n  if (!(x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined)) {\n    return x;\n  }\n  var depth = x.BS_PRIVATE_NESTED_SOME_NONE;\n  if (depth === 0) {\n    return ;\n  } else {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0\n          };\n  }\n}\n\nfunction option_get(x) {\n  if (x === undefined) {\n    return ;\n  } else {\n    return valFromOption(x);\n  }\n}\n\nfunction option_unwrap(x) {\n  if (x !== undefined) {\n    return x.VAL;\n  } else {\n    return x;\n  }\n}\n\nexports.nullable_to_opt = nullable_to_opt;\nexports.undefined_to_opt = undefined_to_opt;\nexports.null_to_opt = null_to_opt;\nexports.valFromOption = valFromOption;\nexports.some = some;\nexports.isNested = isNested;\nexports.option_get = option_get;\nexports.option_unwrap = option_unwrap;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/caml_option.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/caml_primitive.js":
/*!***********************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/caml_primitive.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n\nfunction caml_int_compare(x, y) {\n  if (x < y) {\n    return -1;\n  } else if (x === y) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_compare(x, y) {\n  if (x) {\n    if (y) {\n      return 0;\n    } else {\n      return 1;\n    }\n  } else if (y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_float_compare(x, y) {\n  if (x === y) {\n    return 0;\n  } else if (x < y) {\n    return -1;\n  } else if (x > y || x === x) {\n    return 1;\n  } else if (y === y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_string_compare(s1, s2) {\n  if (s1 === s2) {\n    return 0;\n  } else if (s1 < s2) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_min(x, y) {\n  if (x) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction caml_int_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_nativeint_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_bool_max(x, y) {\n  if (x) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_nativeint_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nvar caml_nativeint_compare = caml_int_compare;\n\nvar caml_int32_compare = caml_int_compare;\n\nexports.caml_int_compare = caml_int_compare;\nexports.caml_bool_compare = caml_bool_compare;\nexports.caml_float_compare = caml_float_compare;\nexports.caml_nativeint_compare = caml_nativeint_compare;\nexports.caml_string_compare = caml_string_compare;\nexports.caml_int32_compare = caml_int32_compare;\nexports.caml_bool_min = caml_bool_min;\nexports.caml_int_min = caml_int_min;\nexports.caml_float_min = caml_float_min;\nexports.caml_string_min = caml_string_min;\nexports.caml_nativeint_min = caml_nativeint_min;\nexports.caml_int32_min = caml_int32_min;\nexports.caml_bool_max = caml_bool_max;\nexports.caml_int_max = caml_int_max;\nexports.caml_float_max = caml_float_max;\nexports.caml_string_max = caml_string_max;\nexports.caml_nativeint_max = caml_nativeint_max;\nexports.caml_int32_max = caml_int32_max;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/caml_primitive.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/camlinternalLazy.js":
/*!*************************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/camlinternalLazy.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar Caml_exceptions = __webpack_require__(/*! ./caml_exceptions.js */ \"./node_modules/bs-platform/lib/js/caml_exceptions.js\");\n\nfunction is_val(l) {\n  return l.LAZY_DONE;\n}\n\nvar Undefined = Caml_exceptions.create(\"CamlinternalLazy.Undefined\");\n\nfunction forward_with_closure(blk, closure) {\n  var result = closure();\n  blk.VAL = result;\n  blk.LAZY_DONE = true;\n  return result;\n}\n\nfunction raise_undefined() {\n  throw {\n        RE_EXN_ID: Undefined,\n        Error: new Error()\n      };\n}\n\nfunction force(lzv) {\n  if (lzv.LAZY_DONE) {\n    return lzv.VAL;\n  } else {\n    var closure = lzv.VAL;\n    lzv.VAL = raise_undefined;\n    try {\n      return forward_with_closure(lzv, closure);\n    }\n    catch (e){\n      lzv.VAL = (function () {\n          throw e;\n        });\n      throw e;\n    }\n  }\n}\n\nfunction force_val(lzv) {\n  if (lzv.LAZY_DONE) {\n    return lzv.VAL;\n  } else {\n    var closure = lzv.VAL;\n    lzv.VAL = raise_undefined;\n    return forward_with_closure(lzv, closure);\n  }\n}\n\nexports.Undefined = Undefined;\nexports.force = force;\nexports.force_val = force_val;\nexports.is_val = is_val;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/camlinternalLazy.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/curry.js":
/*!**************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/curry.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar Caml_array = __webpack_require__(/*! ./caml_array.js */ \"./node_modules/bs-platform/lib/js/caml_array.js\");\n\nfunction app(_f, _args) {\n  while(true) {\n    var args = _args;\n    var f = _f;\n    var init_arity = f.length;\n    var arity = init_arity === 0 ? 1 : init_arity;\n    var len = args.length;\n    var d = arity - len | 0;\n    if (d === 0) {\n      return f.apply(null, args);\n    }\n    if (d >= 0) {\n      return (function(f,args){\n      return function (x) {\n        return app(f, args.concat([x]));\n      }\n      }(f,args));\n    }\n    _args = Caml_array.caml_array_sub(args, arity, -d | 0);\n    _f = f.apply(null, Caml_array.caml_array_sub(args, 0, arity));\n    continue ;\n  };\n}\n\nfunction _1(o, a0) {\n  var arity = o.length;\n  if (arity === 1) {\n    return o(a0);\n  } else {\n    switch (arity) {\n      case 1 :\n          return o(a0);\n      case 2 :\n          return function (param) {\n            return o(a0, param);\n          };\n      case 3 :\n          return function (param, param$1) {\n            return o(a0, param, param$1);\n          };\n      case 4 :\n          return function (param, param$1, param$2) {\n            return o(a0, param, param$1, param$2);\n          };\n      case 5 :\n          return function (param, param$1, param$2, param$3) {\n            return o(a0, param, param$1, param$2, param$3);\n          };\n      case 6 :\n          return function (param, param$1, param$2, param$3, param$4) {\n            return o(a0, param, param$1, param$2, param$3, param$4);\n          };\n      case 7 :\n          return function (param, param$1, param$2, param$3, param$4, param$5) {\n            return o(a0, param, param$1, param$2, param$3, param$4, param$5);\n          };\n      default:\n        return app(o, [a0]);\n    }\n  }\n}\n\nfunction __1(o) {\n  var arity = o.length;\n  if (arity === 1) {\n    return o;\n  } else {\n    return function (a0) {\n      return _1(o, a0);\n    };\n  }\n}\n\nfunction _2(o, a0, a1) {\n  var arity = o.length;\n  if (arity === 2) {\n    return o(a0, a1);\n  } else {\n    switch (arity) {\n      case 1 :\n          return app(o(a0), [a1]);\n      case 2 :\n          return o(a0, a1);\n      case 3 :\n          return function (param) {\n            return o(a0, a1, param);\n          };\n      case 4 :\n          return function (param, param$1) {\n            return o(a0, a1, param, param$1);\n          };\n      case 5 :\n          return function (param, param$1, param$2) {\n            return o(a0, a1, param, param$1, param$2);\n          };\n      case 6 :\n          return function (param, param$1, param$2, param$3) {\n            return o(a0, a1, param, param$1, param$2, param$3);\n          };\n      case 7 :\n          return function (param, param$1, param$2, param$3, param$4) {\n            return o(a0, a1, param, param$1, param$2, param$3, param$4);\n          };\n      default:\n        return app(o, [\n                    a0,\n                    a1\n                  ]);\n    }\n  }\n}\n\nfunction __2(o) {\n  var arity = o.length;\n  if (arity === 2) {\n    return o;\n  } else {\n    return function (a0, a1) {\n      return _2(o, a0, a1);\n    };\n  }\n}\n\nfunction _3(o, a0, a1, a2) {\n  var arity = o.length;\n  if (arity === 3) {\n    return o(a0, a1, a2);\n  } else {\n    switch (arity) {\n      case 1 :\n          return app(o(a0), [\n                      a1,\n                      a2\n                    ]);\n      case 2 :\n          return app(o(a0, a1), [a2]);\n      case 3 :\n          return o(a0, a1, a2);\n      case 4 :\n          return function (param) {\n            return o(a0, a1, a2, param);\n          };\n      case 5 :\n          return function (param, param$1) {\n            return o(a0, a1, a2, param, param$1);\n          };\n      case 6 :\n          return function (param, param$1, param$2) {\n            return o(a0, a1, a2, param, param$1, param$2);\n          };\n      case 7 :\n          return function (param, param$1, param$2, param$3) {\n            return o(a0, a1, a2, param, param$1, param$2, param$3);\n          };\n      default:\n        return app(o, [\n                    a0,\n                    a1,\n                    a2\n                  ]);\n    }\n  }\n}\n\nfunction __3(o) {\n  var arity = o.length;\n  if (arity === 3) {\n    return o;\n  } else {\n    return function (a0, a1, a2) {\n      return _3(o, a0, a1, a2);\n    };\n  }\n}\n\nfunction _4(o, a0, a1, a2, a3) {\n  var arity = o.length;\n  if (arity === 4) {\n    return o(a0, a1, a2, a3);\n  } else {\n    switch (arity) {\n      case 1 :\n          return app(o(a0), [\n                      a1,\n                      a2,\n                      a3\n                    ]);\n      case 2 :\n          return app(o(a0, a1), [\n                      a2,\n                      a3\n                    ]);\n      case 3 :\n          return app(o(a0, a1, a2), [a3]);\n      case 4 :\n          return o(a0, a1, a2, a3);\n      case 5 :\n          return function (param) {\n            return o(a0, a1, a2, a3, param);\n          };\n      case 6 :\n          return function (param, param$1) {\n            return o(a0, a1, a2, a3, param, param$1);\n          };\n      case 7 :\n          return function (param, param$1, param$2) {\n            return o(a0, a1, a2, a3, param, param$1, param$2);\n          };\n      default:\n        return app(o, [\n                    a0,\n                    a1,\n                    a2,\n                    a3\n                  ]);\n    }\n  }\n}\n\nfunction __4(o) {\n  var arity = o.length;\n  if (arity === 4) {\n    return o;\n  } else {\n    return function (a0, a1, a2, a3) {\n      return _4(o, a0, a1, a2, a3);\n    };\n  }\n}\n\nfunction _5(o, a0, a1, a2, a3, a4) {\n  var arity = o.length;\n  if (arity === 5) {\n    return o(a0, a1, a2, a3, a4);\n  } else {\n    switch (arity) {\n      case 1 :\n          return app(o(a0), [\n                      a1,\n                      a2,\n                      a3,\n                      a4\n                    ]);\n      case 2 :\n          return app(o(a0, a1), [\n                      a2,\n                      a3,\n                      a4\n                    ]);\n      case 3 :\n          return app(o(a0, a1, a2), [\n                      a3,\n                      a4\n                    ]);\n      case 4 :\n          return app(o(a0, a1, a2, a3), [a4]);\n      case 5 :\n          return o(a0, a1, a2, a3, a4);\n      case 6 :\n          return function (param) {\n            return o(a0, a1, a2, a3, a4, param);\n          };\n      case 7 :\n          return function (param, param$1) {\n            return o(a0, a1, a2, a3, a4, param, param$1);\n          };\n      default:\n        return app(o, [\n                    a0,\n                    a1,\n                    a2,\n                    a3,\n                    a4\n                  ]);\n    }\n  }\n}\n\nfunction __5(o) {\n  var arity = o.length;\n  if (arity === 5) {\n    return o;\n  } else {\n    return function (a0, a1, a2, a3, a4) {\n      return _5(o, a0, a1, a2, a3, a4);\n    };\n  }\n}\n\nfunction _6(o, a0, a1, a2, a3, a4, a5) {\n  var arity = o.length;\n  if (arity === 6) {\n    return o(a0, a1, a2, a3, a4, a5);\n  } else {\n    switch (arity) {\n      case 1 :\n          return app(o(a0), [\n                      a1,\n                      a2,\n                      a3,\n                      a4,\n                      a5\n                    ]);\n      case 2 :\n          return app(o(a0, a1), [\n                      a2,\n                      a3,\n                      a4,\n                      a5\n                    ]);\n      case 3 :\n          return app(o(a0, a1, a2), [\n                      a3,\n                      a4,\n                      a5\n                    ]);\n      case 4 :\n          return app(o(a0, a1, a2, a3), [\n                      a4,\n                      a5\n                    ]);\n      case 5 :\n          return app(o(a0, a1, a2, a3, a4), [a5]);\n      case 6 :\n          return o(a0, a1, a2, a3, a4, a5);\n      case 7 :\n          return function (param) {\n            return o(a0, a1, a2, a3, a4, a5, param);\n          };\n      default:\n        return app(o, [\n                    a0,\n                    a1,\n                    a2,\n                    a3,\n                    a4,\n                    a5\n                  ]);\n    }\n  }\n}\n\nfunction __6(o) {\n  var arity = o.length;\n  if (arity === 6) {\n    return o;\n  } else {\n    return function (a0, a1, a2, a3, a4, a5) {\n      return _6(o, a0, a1, a2, a3, a4, a5);\n    };\n  }\n}\n\nfunction _7(o, a0, a1, a2, a3, a4, a5, a6) {\n  var arity = o.length;\n  if (arity === 7) {\n    return o(a0, a1, a2, a3, a4, a5, a6);\n  } else {\n    switch (arity) {\n      case 1 :\n          return app(o(a0), [\n                      a1,\n                      a2,\n                      a3,\n                      a4,\n                      a5,\n                      a6\n                    ]);\n      case 2 :\n          return app(o(a0, a1), [\n                      a2,\n                      a3,\n                      a4,\n                      a5,\n                      a6\n                    ]);\n      case 3 :\n          return app(o(a0, a1, a2), [\n                      a3,\n                      a4,\n                      a5,\n                      a6\n                    ]);\n      case 4 :\n          return app(o(a0, a1, a2, a3), [\n                      a4,\n                      a5,\n                      a6\n                    ]);\n      case 5 :\n          return app(o(a0, a1, a2, a3, a4), [\n                      a5,\n                      a6\n                    ]);\n      case 6 :\n          return app(o(a0, a1, a2, a3, a4, a5), [a6]);\n      case 7 :\n          return o(a0, a1, a2, a3, a4, a5, a6);\n      default:\n        return app(o, [\n                    a0,\n                    a1,\n                    a2,\n                    a3,\n                    a4,\n                    a5,\n                    a6\n                  ]);\n    }\n  }\n}\n\nfunction __7(o) {\n  var arity = o.length;\n  if (arity === 7) {\n    return o;\n  } else {\n    return function (a0, a1, a2, a3, a4, a5, a6) {\n      return _7(o, a0, a1, a2, a3, a4, a5, a6);\n    };\n  }\n}\n\nfunction _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {\n  var arity = o.length;\n  if (arity === 8) {\n    return o(a0, a1, a2, a3, a4, a5, a6, a7);\n  } else {\n    switch (arity) {\n      case 1 :\n          return app(o(a0), [\n                      a1,\n                      a2,\n                      a3,\n                      a4,\n                      a5,\n                      a6,\n                      a7\n                    ]);\n      case 2 :\n          return app(o(a0, a1), [\n                      a2,\n                      a3,\n                      a4,\n                      a5,\n                      a6,\n                      a7\n                    ]);\n      case 3 :\n          return app(o(a0, a1, a2), [\n                      a3,\n                      a4,\n                      a5,\n                      a6,\n                      a7\n                    ]);\n      case 4 :\n          return app(o(a0, a1, a2, a3), [\n                      a4,\n                      a5,\n                      a6,\n                      a7\n                    ]);\n      case 5 :\n          return app(o(a0, a1, a2, a3, a4), [\n                      a5,\n                      a6,\n                      a7\n                    ]);\n      case 6 :\n          return app(o(a0, a1, a2, a3, a4, a5), [\n                      a6,\n                      a7\n                    ]);\n      case 7 :\n          return app(o(a0, a1, a2, a3, a4, a5, a6), [a7]);\n      default:\n        return app(o, [\n                    a0,\n                    a1,\n                    a2,\n                    a3,\n                    a4,\n                    a5,\n                    a6,\n                    a7\n                  ]);\n    }\n  }\n}\n\nfunction __8(o) {\n  var arity = o.length;\n  if (arity === 8) {\n    return o;\n  } else {\n    return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n      return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);\n    };\n  }\n}\n\nexports.app = app;\nexports._1 = _1;\nexports.__1 = __1;\nexports._2 = _2;\nexports.__2 = __2;\nexports._3 = _3;\nexports.__3 = __3;\nexports._4 = _4;\nexports.__4 = __4;\nexports._5 = _5;\nexports.__5 = __5;\nexports._6 = _6;\nexports.__6 = __6;\nexports._7 = _7;\nexports.__7 = __7;\nexports._8 = _8;\nexports.__8 = __8;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/curry.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/js_int.js":
/*!***************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/js_int.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n\nfunction equal(x, y) {\n  return x === y;\n}\n\nvar max = 2147483647;\n\nvar min = -2147483648;\n\nexports.equal = equal;\nexports.max = max;\nexports.min = min;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/js_int.js?");

/***/ }),

/***/ "./node_modules/bs-platform/lib/js/js_math.js":
/*!****************************************************!*\
  !*** ./node_modules/bs-platform/lib/js/js_math.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar Js_int = __webpack_require__(/*! ./js_int.js */ \"./node_modules/bs-platform/lib/js/js_int.js\");\n\nfunction unsafe_ceil(prim) {\n  return Math.ceil(prim);\n}\n\nfunction ceil_int(f) {\n  if (f > Js_int.max) {\n    return Js_int.max;\n  } else if (f < Js_int.min) {\n    return Js_int.min;\n  } else {\n    return Math.ceil(f);\n  }\n}\n\nfunction unsafe_floor(prim) {\n  return Math.floor(prim);\n}\n\nfunction floor_int(f) {\n  if (f > Js_int.max) {\n    return Js_int.max;\n  } else if (f < Js_int.min) {\n    return Js_int.min;\n  } else {\n    return Math.floor(f);\n  }\n}\n\nfunction random_int(min, max) {\n  return floor_int(Math.random() * (max - min | 0)) + min | 0;\n}\n\nvar ceil = ceil_int;\n\nvar floor = floor_int;\n\nexports.unsafe_ceil = unsafe_ceil;\nexports.ceil_int = ceil_int;\nexports.ceil = ceil;\nexports.unsafe_floor = unsafe_floor;\nexports.floor_int = floor_int;\nexports.floor = floor;\nexports.random_int = random_int;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./node_modules/bs-platform/lib/js/js_math.js?");

/***/ }),

/***/ "./src/CPU.bs.js":
/*!***********************!*\
  !*** ./src/CPU.bs.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Generated by ReScript, PLEASE EDIT WITH CARE\n\n\nvar Fontset = __webpack_require__(/*! ./Fontset.bs.js */ \"./src/Fontset.bs.js\");\nvar Js_math = __webpack_require__(/*! bs-platform/lib/js/js_math.js */ \"./node_modules/bs-platform/lib/js/js_math.js\");\nvar Belt_Array = __webpack_require__(/*! bs-platform/lib/js/belt_Array.js */ \"./node_modules/bs-platform/lib/js/belt_Array.js\");\nvar Caml_array = __webpack_require__(/*! bs-platform/lib/js/caml_array.js */ \"./node_modules/bs-platform/lib/js/caml_array.js\");\nvar Caml_format = __webpack_require__(/*! bs-platform/lib/js/caml_format.js */ \"./node_modules/bs-platform/lib/js/caml_format.js\");\nvar Instruction = __webpack_require__(/*! ./Instruction.bs.js */ \"./src/Instruction.bs.js\");\nvar Caml_exceptions = __webpack_require__(/*! bs-platform/lib/js/caml_exceptions.js */ \"./node_modules/bs-platform/lib/js/caml_exceptions.js\");\n\nfunction getVariable(opcode) {\n  switch (opcode.TAG | 0) {\n    case /* KK */0 :\n        return opcode._0 & 255;\n    case /* N */1 :\n        return opcode._0 & 15;\n    case /* NNN */2 :\n        return opcode._0 & 4095;\n    case /* X */3 :\n        return ((opcode._0 & 3840) >>> 8);\n    case /* Y */4 :\n        return ((opcode._0 & 240) >>> 4);\n    \n  }\n}\n\nvar getEmpty_memory = new Uint8Array(4096);\n\nvar getEmpty_v = new Uint8Array(16);\n\nvar getEmpty_stack = new Uint16Array(16);\n\nvar getEmpty_ui = Belt_Array.make(32, Belt_Array.make(64, 0));\n\nvar getEmpty_keys = Belt_Array.make(16, /* Down */1);\n\nvar getEmpty = {\n  memory: getEmpty_memory,\n  v: getEmpty_v,\n  i: 0,\n  dt: 0,\n  st: 0,\n  pc: 512,\n  sp: 0,\n  stack: getEmpty_stack,\n  ui: getEmpty_ui,\n  keys: getEmpty_keys,\n  halted: false\n};\n\nfunction loadFontSet(cpu) {\n  console.log(\"Loading fontset\");\n  var memory = cpu.memory;\n  for(var i = 0 ,i_finish = Fontset.get.length; i <= i_finish; ++i){\n    memory[i] = Fontset.get[i];\n  }\n  return {\n          memory: memory,\n          v: cpu.v,\n          i: cpu.i,\n          dt: cpu.dt,\n          st: cpu.st,\n          pc: cpu.pc,\n          sp: cpu.sp,\n          stack: cpu.stack,\n          ui: cpu.ui,\n          keys: cpu.keys,\n          halted: cpu.halted\n        };\n}\n\nvar Rom_not_found = Caml_exceptions.create(\"CPU.Rom_not_found\");\n\nfunction loadRom(romBuffer) {\n  console.log(\"Adding rom to memory\");\n  if (romBuffer !== undefined) {\n    var memory = getEmpty_memory;\n    for(var i = 0 ,i_finish = romBuffer.length; i < i_finish; ++i){\n      memory[512 + i | 0] = Caml_format.caml_int_of_string(\"0x\" + Caml_array.get(romBuffer, i));\n    }\n    return {\n            memory: memory,\n            v: getEmpty_v,\n            i: 0,\n            dt: 0,\n            st: 0,\n            pc: 512,\n            sp: 0,\n            stack: getEmpty_stack,\n            ui: getEmpty_ui,\n            keys: getEmpty_keys,\n            halted: false\n          };\n  }\n  throw {\n        RE_EXN_ID: Rom_not_found,\n        Error: new Error()\n      };\n}\n\nfunction $$fetch(cpu) {\n  var pc = cpu.pc;\n  var memory = cpu.memory;\n  var codes = [\n    memory[pc],\n    memory[pc + 1 | 0]\n  ];\n  return [\n          {\n            memory: cpu.memory,\n            v: cpu.v,\n            i: cpu.i,\n            dt: cpu.dt,\n            st: cpu.st,\n            pc: pc + 2 | 0,\n            sp: cpu.sp,\n            stack: cpu.stack,\n            ui: cpu.ui,\n            keys: cpu.keys,\n            halted: cpu.halted\n          },\n          (Caml_array.get(codes, 0) << 8) + Caml_array.get(codes, 1) | 0\n        ];\n}\n\nvar decode = Instruction.get;\n\nfunction execute(cpu, param) {\n  var opcode = param[0];\n  switch (param[1]) {\n    case /* CLS */0 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: cpu.pc,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: Belt_Array.make(32, Belt_Array.make(64, 0)),\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* RET */1 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: cpu.stack[cpu.sp],\n                sp: cpu.sp - 1 | 0,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* JP_addr */2 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: getVariable({\n                      TAG: /* NNN */2,\n                      _0: opcode\n                    }),\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* CALL_addr */3 :\n        var sp = cpu.sp + 1 | 0;\n        cpu.stack[sp] = cpu.pc;\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: getVariable({\n                      TAG: /* NNN */2,\n                      _0: opcode\n                    }),\n                sp: sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* SE_Vx_byte */4 :\n        if (cpu.v[getVariable({\n                    TAG: /* X */3,\n                    _0: opcode\n                  })] === getVariable({\n                TAG: /* KK */0,\n                _0: opcode\n              })) {\n          return {\n                  memory: cpu.memory,\n                  v: cpu.v,\n                  i: cpu.i,\n                  dt: cpu.dt,\n                  st: cpu.st,\n                  pc: cpu.pc + 2 | 0,\n                  sp: cpu.sp,\n                  stack: cpu.stack,\n                  ui: cpu.ui,\n                  keys: cpu.keys,\n                  halted: cpu.halted\n                };\n        } else {\n          return cpu;\n        }\n    case /* SNE_Vx_byte */5 :\n        if (cpu.v[getVariable({\n                    TAG: /* X */3,\n                    _0: opcode\n                  })] !== getVariable({\n                TAG: /* KK */0,\n                _0: opcode\n              })) {\n          return {\n                  memory: cpu.memory,\n                  v: cpu.v,\n                  i: cpu.i,\n                  dt: cpu.dt,\n                  st: cpu.st,\n                  pc: cpu.pc + 2 | 0,\n                  sp: cpu.sp,\n                  stack: cpu.stack,\n                  ui: cpu.ui,\n                  keys: cpu.keys,\n                  halted: cpu.halted\n                };\n        } else {\n          return cpu;\n        }\n    case /* SE_Vx_Vy */6 :\n        if (cpu.v[getVariable({\n                    TAG: /* X */3,\n                    _0: opcode\n                  })] === cpu.v[getVariable({\n                    TAG: /* Y */4,\n                    _0: opcode\n                  })]) {\n          return {\n                  memory: cpu.memory,\n                  v: cpu.v,\n                  i: cpu.i,\n                  dt: cpu.dt,\n                  st: cpu.st,\n                  pc: cpu.pc + 2 | 0,\n                  sp: cpu.sp,\n                  stack: cpu.stack,\n                  ui: cpu.ui,\n                  keys: cpu.keys,\n                  halted: cpu.halted\n                };\n        } else {\n          return cpu;\n        }\n    case /* LD_Vx_byte */7 :\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = getVariable({\n              TAG: /* KK */0,\n              _0: opcode\n            });\n        return cpu;\n    case /* ADD_Vx_byte */8 :\n        var vx = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = vx + getVariable({\n              TAG: /* KK */0,\n              _0: opcode\n            }) | 0;\n        return cpu;\n    case /* LD_Vx_Vy */9 :\n        var vy = cpu.v[getVariable({\n                  TAG: /* Y */4,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = vy;\n        return cpu;\n    case /* OR_Vx_Vy */10 :\n        var _or = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] | cpu.v[getVariable({\n                  TAG: /* Y */4,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = _or;\n        return cpu;\n    case /* AND_Vx_Vy */11 :\n        var _and = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] & cpu.v[getVariable({\n                  TAG: /* Y */4,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = _and;\n        return cpu;\n    case /* XOR_Vx_Vy */12 :\n        var _xor = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] ^ cpu.v[getVariable({\n                  TAG: /* Y */4,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = _xor;\n        return cpu;\n    case /* ADD_Vx_Vy */13 :\n        var x = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        var y = cpu.v[getVariable({\n                  TAG: /* Y */4,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = x + y | 0;\n        cpu.v[15] = (x + y | 0) > 255 ? 1 : 0;\n        return cpu;\n    case /* SUB_Vx_Vy */14 :\n        var x$1 = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        var y$1 = cpu.v[getVariable({\n                  TAG: /* Y */4,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = x$1 - y$1 | 0;\n        cpu.v[15] = x$1 > y$1 ? 1 : 0;\n        return cpu;\n    case /* SHR_Vx_Vy */15 :\n        var x$2 = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = (x$2 >>> 1);\n        cpu.v[15] = (x$2 & 1) === 1 ? 1 : 0;\n        return cpu;\n    case /* SUBN_Vx_Vy */16 :\n        var x$3 = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        var y$2 = cpu.v[getVariable({\n                  TAG: /* Y */4,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = y$2 - x$3 | 0;\n        cpu.v[15] = y$2 > x$3 ? 1 : 0;\n        return cpu;\n    case /* SHL_Vx */17 :\n        var x$4 = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = (x$4 << 1);\n        cpu.v[15] = (x$4 >>> 7);\n        return cpu;\n    case /* SNE_Vx_Vy */18 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: cpu.v[getVariable({\n                          TAG: /* X */3,\n                          _0: opcode\n                        })] !== cpu.v[getVariable({\n                          TAG: /* Y */4,\n                          _0: opcode\n                        })] ? cpu.pc + 2 | 0 : cpu.pc,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* LD_I_addr */19 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: getVariable({\n                      TAG: /* NNN */2,\n                      _0: opcode\n                    }),\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: cpu.pc,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* JP_V0_addr */20 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: getVariable({\n                      TAG: /* NNN */2,\n                      _0: opcode\n                    }) + cpu.v[0] | 0,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* RND_Vx_byte */21 :\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = Js_math.random_int(0, 255) & getVariable({\n              TAG: /* KK */0,\n              _0: opcode\n            });\n        return cpu;\n    case /* DRW_Vx_Vy_n */22 :\n        var x$5 = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        var y$3 = cpu.v[getVariable({\n                  TAG: /* Y */4,\n                  _0: opcode\n                })];\n        var n = getVariable({\n              TAG: /* N */1,\n              _0: opcode\n            });\n        cpu.v[15] = 0;\n        for(var spriteX = 0; spriteX <= n; ++spriteX){\n          var spriteRow = cpu.memory[cpu.i + spriteX | 0];\n          for(var bit = 0; bit <= 7; ++bit){\n            var pixel = ((spriteRow & (1 << (7 - bit | 0))) >>> (7 - bit | 0)) | 0;\n            var w = (x$5 + bit | 0) % 64;\n            var h = (y$3 + spriteX | 0) % 32;\n            if ((Caml_array.get(Caml_array.get(cpu.ui, h), w) & pixel) === 1) {\n              cpu.v[15] = 1;\n            }\n            Caml_array.set(Caml_array.get(cpu.ui, h), w, Caml_array.get(Caml_array.get(cpu.ui, h), w) ^ pixel);\n          }\n        }\n        return cpu;\n    case /* SKP_Vx */23 :\n        var x$6 = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        var match = Caml_array.get(cpu.keys, x$6);\n        if (match) {\n          return {\n                  memory: cpu.memory,\n                  v: cpu.v,\n                  i: cpu.i,\n                  dt: cpu.dt,\n                  st: cpu.st,\n                  pc: cpu.pc + 2 | 0,\n                  sp: cpu.sp,\n                  stack: cpu.stack,\n                  ui: cpu.ui,\n                  keys: cpu.keys,\n                  halted: cpu.halted\n                };\n        } else {\n          return cpu;\n        }\n    case /* SKNP_Vx */24 :\n        var x$7 = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        var match$1 = Caml_array.get(cpu.keys, x$7);\n        if (match$1) {\n          return cpu;\n        } else {\n          return {\n                  memory: cpu.memory,\n                  v: cpu.v,\n                  i: cpu.i,\n                  dt: cpu.dt,\n                  st: cpu.st,\n                  pc: cpu.pc + 2 | 0,\n                  sp: cpu.sp,\n                  stack: cpu.stack,\n                  ui: cpu.ui,\n                  keys: cpu.keys,\n                  halted: cpu.halted\n                };\n        }\n    case /* LD_Vx_DT */25 :\n        cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })] = cpu.dt;\n        return cpu;\n    case /* LD_Vx_K */26 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: cpu.pc,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: true\n              };\n    case /* LD_DT_Vx */27 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.v[getVariable({\n                          TAG: /* X */3,\n                          _0: opcode\n                        })],\n                st: cpu.st,\n                pc: cpu.pc,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* LD_ST_Vx */28 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i,\n                dt: cpu.dt,\n                st: cpu.v[getVariable({\n                          TAG: /* X */3,\n                          _0: opcode\n                        })],\n                pc: cpu.pc,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* ADD_I_Vx */29 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: cpu.i + cpu.v[getVariable({\n                          TAG: /* X */3,\n                          _0: opcode\n                        })] | 0,\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: cpu.pc,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* LD_F_Vx */30 :\n        return {\n                memory: cpu.memory,\n                v: cpu.v,\n                i: Math.imul(cpu.v[getVariable({\n                              TAG: /* X */3,\n                              _0: opcode\n                            })], 5),\n                dt: cpu.dt,\n                st: cpu.st,\n                pc: cpu.pc,\n                sp: cpu.sp,\n                stack: cpu.stack,\n                ui: cpu.ui,\n                keys: cpu.keys,\n                halted: cpu.halted\n              };\n    case /* LD_B_Vx */31 :\n        var x$8 = cpu.v[getVariable({\n                  TAG: /* X */3,\n                  _0: opcode\n                })];\n        var hundreds = Math.imul((x$8 / 100 | 0) % 10, 100);\n        var tens = Math.imul((x$8 / 10 | 0) % 10, 10);\n        var ones = (x$8 / 1 | 0) % 10;\n        cpu.v[cpu.i] = hundreds;\n        cpu.v[cpu.i + 1 | 0] = tens;\n        cpu.v[cpu.i + 2 | 0] = ones;\n        return cpu;\n    case /* LD_I_Vx */32 :\n        for(var v = 0 ,v_finish = cpu.v[getVariable({\n                    TAG: /* X */3,\n                    _0: opcode\n                  })]; v <= v_finish; ++v){\n          cpu.memory[cpu.i + v | 0] = cpu.v[v];\n        }\n        return cpu;\n    case /* LD_Vx_I */33 :\n        for(var v$1 = 0 ,v_finish$1 = cpu.v[getVariable({\n                    TAG: /* X */3,\n                    _0: opcode\n                  })]; v$1 <= v_finish$1; ++v$1){\n          cpu.v[v$1] = cpu.memory[cpu.i + v$1 | 0];\n        }\n        return cpu;\n    \n  }\n}\n\nfunction cycle(cpu) {\n  var match = $$fetch(cpu);\n  var decoded = Instruction.get(match[1]);\n  var cpu$1 = execute(match[0], decoded);\n  setTimeout((function (param) {\n          return cycle(cpu$1);\n        }), 200);\n  \n}\n\nfunction init(rom) {\n  console.log(\"Starting CPU\");\n  return cycle(loadFontSet(loadRom(rom)));\n}\n\nvar memory_offset = 512;\n\nvar fps = 15;\n\nvar uiDimension = {\n  width: 64,\n  height: 32\n};\n\nexports.memory_offset = memory_offset;\nexports.fps = fps;\nexports.uiDimension = uiDimension;\nexports.getVariable = getVariable;\nexports.getEmpty = getEmpty;\nexports.loadFontSet = loadFontSet;\nexports.Rom_not_found = Rom_not_found;\nexports.loadRom = loadRom;\nexports.$$fetch = $$fetch;\nexports.decode = decode;\nexports.execute = execute;\nexports.cycle = cycle;\nexports.init = init;\n/* getEmpty Not a pure module */\n\n\n//# sourceURL=webpack://rescript-project-template/./src/CPU.bs.js?");

/***/ }),

/***/ "./src/Fontset.bs.js":
/*!***************************!*\
  !*** ./src/Fontset.bs.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// Generated by ReScript, PLEASE EDIT WITH CARE\n\n\n\nvar get = new Uint8Array([\n      240,\n      144,\n      144,\n      144,\n      240,\n      32,\n      96,\n      32,\n      32,\n      112,\n      240,\n      16,\n      240,\n      128,\n      240,\n      240,\n      16,\n      240,\n      16,\n      240,\n      144,\n      144,\n      240,\n      16,\n      16,\n      240,\n      128,\n      240,\n      16,\n      240,\n      240,\n      128,\n      240,\n      144,\n      240,\n      240,\n      16,\n      32,\n      64,\n      64,\n      240,\n      144,\n      240,\n      144,\n      240,\n      240,\n      144,\n      240,\n      16,\n      240,\n      240,\n      144,\n      240,\n      144,\n      144,\n      224,\n      144,\n      224,\n      144,\n      224,\n      240,\n      128,\n      128,\n      128,\n      240,\n      224,\n      144,\n      144,\n      144,\n      224,\n      240,\n      128,\n      240,\n      128,\n      240,\n      240,\n      128,\n      240,\n      128,\n      128\n    ]);\n\nexports.get = get;\n/* get Not a pure module */\n\n\n//# sourceURL=webpack://rescript-project-template/./src/Fontset.bs.js?");

/***/ }),

/***/ "./src/Instruction.bs.js":
/*!*******************************!*\
  !*** ./src/Instruction.bs.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// Generated by ReScript, PLEASE EDIT WITH CARE\n\n\n\nvar instructionSet = [\n  {\n    pattern: 224,\n    mask: 65535,\n    t: /* CLS */0\n  },\n  {\n    pattern: 238,\n    mask: 65535,\n    t: /* RET */1\n  },\n  {\n    pattern: 4096,\n    mask: 61440,\n    t: /* JP_addr */2\n  },\n  {\n    pattern: 8192,\n    mask: 61440,\n    t: /* CALL_addr */3\n  },\n  {\n    pattern: 12288,\n    mask: 61440,\n    t: /* SE_Vx_byte */4\n  },\n  {\n    pattern: 16384,\n    mask: 61440,\n    t: /* SNE_Vx_byte */5\n  },\n  {\n    pattern: 20480,\n    mask: 61455,\n    t: /* SE_Vx_Vy */6\n  },\n  {\n    pattern: 24576,\n    mask: 61440,\n    t: /* LD_Vx_byte */7\n  },\n  {\n    pattern: 28672,\n    mask: 61440,\n    t: /* ADD_Vx_byte */8\n  },\n  {\n    pattern: 32768,\n    mask: 61455,\n    t: /* LD_Vx_Vy */9\n  },\n  {\n    pattern: 32769,\n    mask: 61455,\n    t: /* OR_Vx_Vy */10\n  },\n  {\n    pattern: 32770,\n    mask: 61455,\n    t: /* AND_Vx_Vy */11\n  },\n  {\n    pattern: 32771,\n    mask: 61455,\n    t: /* XOR_Vx_Vy */12\n  },\n  {\n    pattern: 32772,\n    mask: 61455,\n    t: /* ADD_Vx_Vy */13\n  },\n  {\n    pattern: 32773,\n    mask: 61455,\n    t: /* SUB_Vx_Vy */14\n  },\n  {\n    pattern: 32774,\n    mask: 61455,\n    t: /* SHR_Vx_Vy */15\n  },\n  {\n    pattern: 32775,\n    mask: 61455,\n    t: /* SUBN_Vx_Vy */16\n  },\n  {\n    pattern: 32782,\n    mask: 61455,\n    t: /* SHL_Vx */17\n  },\n  {\n    pattern: 36864,\n    mask: 61455,\n    t: /* SNE_Vx_Vy */18\n  },\n  {\n    pattern: 40960,\n    mask: 61440,\n    t: /* LD_I_addr */19\n  },\n  {\n    pattern: 45056,\n    mask: 61440,\n    t: /* JP_V0_addr */20\n  },\n  {\n    pattern: 49152,\n    mask: 61440,\n    t: /* RND_Vx_byte */21\n  },\n  {\n    pattern: 53248,\n    mask: 61440,\n    t: /* DRW_Vx_Vy_n */22\n  },\n  {\n    pattern: 57502,\n    mask: 61695,\n    t: /* SKP_Vx */23\n  },\n  {\n    pattern: 57505,\n    mask: 61695,\n    t: /* SKNP_Vx */24\n  },\n  {\n    pattern: 61447,\n    mask: 61695,\n    t: /* LD_Vx_DT */25\n  },\n  {\n    pattern: 61450,\n    mask: 61695,\n    t: /* LD_Vx_K */26\n  },\n  {\n    pattern: 61461,\n    mask: 61695,\n    t: /* LD_DT_Vx */27\n  },\n  {\n    pattern: 61464,\n    mask: 61695,\n    t: /* LD_ST_Vx */28\n  },\n  {\n    pattern: 61470,\n    mask: 61695,\n    t: /* ADD_I_Vx */29\n  },\n  {\n    pattern: 61481,\n    mask: 61695,\n    t: /* LD_F_Vx */30\n  },\n  {\n    pattern: 61491,\n    mask: 61695,\n    t: /* LD_B_Vx */31\n  },\n  {\n    pattern: 61525,\n    mask: 61695,\n    t: /* LD_I_Vx */32\n  },\n  {\n    pattern: 61541,\n    mask: 61695,\n    t: /* LD_Vx_I */33\n  }\n];\n\nfunction get(opcode) {\n  var i = instructionSet.find(function (i) {\n        return (opcode & i.mask) === i.pattern;\n      });\n  if (i !== undefined) {\n    return [\n            opcode,\n            i.t\n          ];\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nexports.instructionSet = instructionSet;\nexports.get = get;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./src/Instruction.bs.js?");

/***/ }),

/***/ "./src/Reschip8.bs.js":
/*!****************************!*\
  !*** ./src/Reschip8.bs.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Generated by ReScript, PLEASE EDIT WITH CARE\n\n\nvar CPU = __webpack_require__(/*! ./CPU.bs.js */ \"./src/CPU.bs.js\");\nvar RomLoader = __webpack_require__(/*! ./RomLoader.bs.js */ \"./src/RomLoader.bs.js\");\nvar CamlinternalLazy = __webpack_require__(/*! bs-platform/lib/js/camlinternalLazy.js */ \"./node_modules/bs-platform/lib/js/camlinternalLazy.js\");\n\nvar rom = RomLoader.toBuffer(CamlinternalLazy.force(RomLoader.load));\n\nconsole.log(rom);\n\nconsole.log(\"tss\");\n\nCPU.init(rom);\n\nexports.rom = rom;\n/* rom Not a pure module */\n\n\n//# sourceURL=webpack://rescript-project-template/./src/Reschip8.bs.js?");

/***/ }),

/***/ "./src/RomLoader.bs.js":
/*!*****************************!*\
  !*** ./src/RomLoader.bs.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Generated by ReScript, PLEASE EDIT WITH CARE\n\n\nvar Caml_option = __webpack_require__(/*! bs-platform/lib/js/caml_option.js */ \"./node_modules/bs-platform/lib/js/caml_option.js\");\n\nvar load = {\n  LAZY_DONE: false,\n  VAL: (function () {\n      console.log(\"Reading temporary from memory\");\n      return \"60006100a222c2013201a21ed0147004304012046000710431201204121c8040201020408010\";\n    })\n};\n\nfunction toBuffer(hex) {\n  return Caml_option.null_to_opt(hex.match(/.{1,2}/g));\n}\n\nexports.load = load;\nexports.toBuffer = toBuffer;\n/* No side effect */\n\n\n//# sourceURL=webpack://rescript-project-template/./src/RomLoader.bs.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/Reschip8.bs.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;